This work is licensed under the GNU General Public License v3.0 or later (GPL).
For more information, see https://www.gnu.org/licenses/gpl-3.0.html.


What's new in Blender 4.1

'''''

Blender 4.1 Table Of Contents

Section 1. Blender 4.1: Animation & Rigging¬∂
Section 2. Blender 4.1: Compositor¬∂
Section 3. Blender 4.1: Cycles¬∂
Section 4. Blender 4.1: EEVEE¬∂
Section 5. Blender 4.1: Geometry Nodes¬∂
Section 6. Blender 4.1: Import & Export¬∂
Section 7. Blender 4.1: Modeling¬∂
Section 8. Blender 4.1: Python API¬∂
Section 9. Blender 4.1: Rendering¬∂
Section 10. Blender 4.1: Sculpting¬∂
Section 11. Blender 4.1: Sequencer¬∂
Section 12. Blender 4.1: User Interface¬∂
Section 13. Blender 4.1: Add-ons¬∂

'''''

1. Blender 4.1: Animation & Rigging¬∂

Blender 4.1: Animation & Rigging
¬∂
Bone Collections
¬∂
Bone Collections are now hierarchical
(
129fb2eab8
### Commit Summary: Anim: make bone collections hierarchical ¬∑ 129fb2eab8 - blender - Blender Projects
### Commit Details:
Make it possible to nest bone collections. The data structure on the
armature is still a flat array. It is organised as follows:

- Sibling collections (i.e. ones with the same parent) are stored
  sequentially in the array.
- Each bone collection keep track of the number of children, and the
  index of the first child.
- Root collections (i.e. ones without parent) are stored as the first
  elements in the array.
- The number of root collections is stored on the Armature.

This commit also contains the following:

- Replaced the flat UIList of bone collections with a tree view.
- Updated the M/Shift+M operators (move/assign to collection) to work
  with hierarchical bone collections.
- Updated RNA interface to expose only root collections at
  `armature.collections`. All collections are available on
  `armature.collections.all`, and children at `bonecollection.children`.
- Library override support. Only new roots + their subtrees can be added
  via overrides.

See
#115934
Co-authored with
@nathanvegdahl
and
@nrupsis
.

#115945
-------
). The
collections are shown in a tree instead of a flat list, where they can be
rearranged and nested via drag-and-drop. The outliner also shows the bone
collection hierarchy (
2e2b5dcd52
### Commit Summary: Anim: Outliner, show bone collections in their hierarchy ¬∑ 2e2b5dcd52 - blender - Blender Projects
### Commit Details:
The Outliner now shows an Armature's bone collections as a hierarchy
instead of a flat list.
-------
).
Screenshot of the Bone Collections in the Outliner in Blender 4.1
Visibility is determined by the bone collection itself, and its ancestors: a
bone collection is only visible when its parent, grandparent, etc. are visible
(
6cfbf9ef2f
### Commit Summary: Anim: hierarchical visibility for bone collections ¬∑ 6cfbf9ef2f - blender - Blender Projects
### Commit Details:
Bone collection visibility now respects their hierarchy.

A bone collection is only visible when it is marked as visible and all
its ancestors (so parents, greatparents, etc.) are visible. Root bone
collections have no ancestors by definition, and only consider their own
visibility.

The effective ancestors' visibility is stored on each bone collection,
in its `BONE_COLLECTION_ANCESTORS_VISIBLE` flag. This makes it possible
to determine the effective visibility from just the flags of the bone
collection itself.

The `BONE_COLLECTION_ANCESTORS_VISIBLE` flag is now stored, with the
other flags, in `BoneCollection::flags`. This means that it's stored in
DNA, even though it's derived data and should actually be stored in a
runtime struct. However, `BoneCollection` doesn't have any runtime
struct yet, and I don't feel that the introduction of this flag is a
good enough reason to introduce that just yet.

#116784
-------
). In other words: hiding a bone collection will also
hide its children.
Screenshot of the Bone Collections in the Armature Properties panel in Blender 4.1
Bone Collections can be 'solo'ed
with the ‚òÜ icon. When
any
bone collection
is marked as 'solo', shown as¬†‚òÖ in the interface, the regular visibility
options (the üëÅ¬†icon) are overridden. Only the bone collections with
a¬†‚òÖ are then shown. This makes it possible to, for example, quickly show
certain bone collections without altering the regular visibility setup.
An
Un-Solo All
operator is available to disable all 'solo'ed bone
collections, and return to the regular visibility rules.
Screenshot of the Bone Collections in the Bone Properties, Relations panel
The Bone Properties' Relations panel also shows which Bone Collections the Bone is assigned to,
including visibility & solo toggles. The bone can also be un-assigned from its collections here.
Python API
¬∂
import
bpy
# Create bone collections
armature
=
bpy
.
context
.
object
.
data
bcoll_root
=
armature
.
collections
.
new
(
"A Root Collection"
)
bcoll_child
=
armature
.
collections
.
new
(
"Child Collection"
,
parent
=
bcoll_root
)
# Moving the bone collection after it has been created.
bcoll
=
armature
.
collections
.
new
(
"collection"
)
bcoll
.
parent
=
bcoll_root
# Assign a new parent collection.
bcoll
.
child_number
=
0
# Move to be the first of its siblings.
# Access to the top level (aka 'root') collections:
for
bcoll
in
armature
.
collections
:
print
(
f
'Root collection:
{
bcoll
.
name
}
'
)
# Access to all collections:
for
bcoll
in
armature
.
collections_all
:
print
(
f
'Collection:
{
bcoll
.
name
}
'
)
# Access to all collections, backward-compatible with Blender 4.0.
# NOTE: this does NOT return the collections in a strict top-to-bottom order.
# See the link below this code for more info.
colls_all
=
getattr
(
armature
,
'collections_all'
,
armature
.
collections
)
for
bcoll
in
bcolls_all
:
print
(
f
'Collection:
{
bcoll
.
name
}
'
)
# Assigned bones can be retrieved hierarchically:
bcoll_child
.
assign
(
armature
.
bones
[
'thigh.L'
])
for
bone
in
bcoll_root
.
bones_recursive
:
print
(
bone
.
name
)
For more information about the bone collections, see
Bone Collections: Storage and Hierarchy
.
NLA
¬∂
Add new channel options to Action bake, so you can choose what to bake (loc/rot/scale and custom
  properties) (
dd5b870d15
### Commit Summary: Anim: Add channel type options to the Bake Action operator ¬∑ dd5b870d15 - blender - Blender Projects
### Commit Details:
Currently, we're limited to the type of Bake Data, without any control over the channels that get baked.

With this change, the user now has a fine degree of control as to which types of f-curve data will be written to the baked action (i.e., location, rotation, scale & b-bone channels).

Co-author
@cmbasnett
#111997
-------
,
4ddb52a775
### Commit Summary: Anim: Action bake custom properties ¬∑ 4ddb52a775 - blender - Blender Projects
### Commit Details:
Add custom properties to Action Bake.

objects will bake all animatable custom properties. Armatures will bake all bone custom properties,
as well as object (armature) custom properties.

#113208
-------
).
Rename "NLA Channels" to "NLA Tracks"
  (
661e7e451a
### Commit Summary: Anim: Rename NLA "Channels" to "Tracks" ¬∑ 661e7e451a - blender - Blender Projects
### Commit Details:
Updating "NLA Channel"  to "NLA Tracks" across board, since the terminology "Tracks" is the most prevalent in operators, code, etc.
-------
).
Screenshot of Blender showing the new Bake Action popup
Weight Paint: Bone Selection
¬∂
Selection mode options in the Weight Paint mode
Bone selection mode is made explicit when you enter weight paint mode with an armature
(
edcac1f48b
### Commit Summary: Fix #44834: Add bone selection icon next to face and vertex selection in weight paint mode ¬∑ edcac1f48b - blender - Blender Projects
### Commit Details:
Currently, in weight paint mode, there is an icon for
face and vertex selection mode, but there isn't one
for the default mode where the user can select a bone
in any tool by alt clicking.
This lack of indication might lead to confusion for the users
when they are not able to select a bone by
alt clicking during weight painting.

By adding a bone selection icon when there is a pose
mode armature, we can communicate to the user that:
1. they can select a bone while the bone selection icon is active.
(when they are not in face or vertex selection mode)
2. they have forgot to select an armature when entering
weight paint mode by not showing the bone selection
icon at all when there is no pose mode armature.

When the bone selection icon is inactive,
the user can't select a bone.
(alt clicking selects face and vertex mode's respective element)

When no armature is selected when entering weight paint mode,
the bone selection icon doesn't show up indicating that the user
has forgot to select an armature.
(The user is also unable to select a bone by alt clicking.)

## Selection tool for bone selection mode
Currently, while selection tools exist for face and vertex
selection mode, one doesn't exist for the default mode
(bone selection mode). As the default mode will be getting
a clear indicator that it will function as a bone selection mode,
I added a selection tool entry for the bone selection mode.

Face and vertex selection modes has the shortcut 1 and 2,
so it seemed natural to give bone selection mode the shortcut of 3.

#115409
-------
). It now has an icon and can be accessed
with the hotkey
3
. In previous versions, this mode would be enabled implicitly when both 'vertex'
and 'face' selection modes were turned off.
Keying
¬∂
Rik Schutte explains these changes in
Keying Animation Updates in Blender 4.1
(YouTube).
Pressing
I
in the viewport will no longer pop up a menu of keying sets. Instead, it will use
  newly added options in the Preferences. These options define which channels get keyed. This makes
  it significantly simpler to set up Blender so that it keys what you need.
  (
a99e419b6e
### Commit Summary: Anim: Insert keyframes without keying sets ¬∑ a99e419b6e - blender - Blender Projects
### Commit Details:
When animators want to key something in the viewport,
the code needs to know *which properties* should be keyed of that selected thing.
So far that was done with keying sets, and a pop-up that let's
you choose the keying set to use. You can get rid of the popup by
choosing a keying set ahead of time. But that is also not always desirable.

That pop-up is quite confusing and gives way too many options.
To simplify this process this PR adds a User Preference option to choose one or more of:
* Location
* Rotation
* Scale
* Rotation Mode
* Custom Properties

Now whenever the `I` key is pressed in the viewport,
and no keying set is enabled, it reads the preferences for which channels to insert.

# User Facing changes
* The popup will not be shown when pressing the hotkey,
 but you can still explicitly use keying sets by going to the menu
* Which channels are keyed is defined by a User Preference setting under animation
* when a keying set is used explicitly, the User Preference settings are ignored

Part of
#113278
#113504
-------
)
There is a new hotkey
K
in Object and Pose Mode which pops up the Keying Set menu.
  This shows the menu even if a keying set is active in the scene.
  (
87fc8e8ddd
### Commit Summary: Anim: Add hotkey for keying set operators ¬∑ 87fc8e8ddd - blender - Blender Projects
### Commit Details:
This is in response to feedback to the changes from
#113504
While it does simplify inserting keyframes,
sometimes artists want to insert keys only to e.g. Location.
This takes longer to do now, since the option is in a menu.

This PR changes the following:

* new `K` hotkey to bring up the "Keying Set" menu.
This will always show the menu, even if a keying set is active.

* `Shift + K` will open a menu to set the active keying set

* with "Pie Menu on Drag" enabled in the user preferences,
hitting `I` and moving the mouse will bring up a pie menu
to insert only specific transform channels

Conceptually this separates the keying set behavior from the
insert keyframe behavior.
`I` will always add keyframes.
While `K` always shows keying set options.

#115798
-------
)
The hotkey to change the active Keying Set has been changed from
Ctrl+Shift+Alt+I
to
Shift+K
.
  (
87fc8e8ddd
### Commit Summary: Anim: Add hotkey for keying set operators ¬∑ 87fc8e8ddd - blender - Blender Projects
### Commit Details:
This is in response to feedback to the changes from
#113504
While it does simplify inserting keyframes,
sometimes artists want to insert keys only to e.g. Location.
This takes longer to do now, since the option is in a menu.

This PR changes the following:

* new `K` hotkey to bring up the "Keying Set" menu.
This will always show the menu, even if a keying set is active.

* `Shift + K` will open a menu to set the active keying set

* with "Pie Menu on Drag" enabled in the user preferences,
hitting `I` and moving the mouse will bring up a pie menu
to insert only specific transform channels

Conceptually this separates the keying set behavior from the
insert keyframe behavior.
`I` will always add keyframes.
While `K` always shows keying set options.

#115798
-------
)
When the User Preference option "Pie Menu on Drag" (in the "Keymap" category)
  is enabled, holding
I
and moving the cursor will show a pie menu to insert one of
  Location, Rotation, Scale and Available.
  (
87fc8e8ddd
### Commit Summary: Anim: Add hotkey for keying set operators ¬∑ 87fc8e8ddd - blender - Blender Projects
### Commit Details:
This is in response to feedback to the changes from
#113504
While it does simplify inserting keyframes,
sometimes artists want to insert keys only to e.g. Location.
This takes longer to do now, since the option is in a menu.

This PR changes the following:

* new `K` hotkey to bring up the "Keying Set" menu.
This will always show the menu, even if a keying set is active.

* `Shift + K` will open a menu to set the active keying set

* with "Pie Menu on Drag" enabled in the user preferences,
hitting `I` and moving the mouse will bring up a pie menu
to insert only specific transform channels

Conceptually this separates the keying set behavior from the
insert keyframe behavior.
`I` will always add keyframes.
While `K` always shows keying set options.

#115798
-------
)
The User Preference option "Only Insert Needed"
  is now split between manual keying and auto-keying.
  (
5e28601d69
### Commit Summary: Anim: Separate keying flags ¬∑ 5e28601d69 - blender - Blender Projects
### Commit Details:
Splits the flag `..._FLAG_INSERTNEEDED` between autokey and
manual keying. The fact that this flag was shared between the two
systems has been the cause of issues in the past. It wouldn't
let you insert a keyframe even though you explicitly used an operator
to do so.

In order to be clearer what options are used where, the user preferences
have been reordered.

By default "Only Insert Needed" will be enabled for auto-keying, but not for manual keying.
The versioning code will enable both if it was enabled previously.

# Code side changes

The keying system has flags that define the behavior
when keys are inserted. Some of those flags were shared
between keying and auto-keying. Some were only used for
auto-keying.
To clarify that, prefix flags that used exclusively in one or the other
system with `AUTOKEY`/`MANUALKEY`

Also the flag name on the user preferences and the tool settings was renamed.
Previously it was called `autokey_flag`. To indicated that it is not only used
for autokeying, rename it `keying_flag`.
Fixes
:
#73773
#115525
-------
)
Drivers
¬∂
Single Property and Context Property driver variables now support a
  fallback value to use if the RNA path lookup fails.
  (
d0ef66ddff
### Commit Summary: Drivers: implement fallback values for RNA path based variables. ¬∑ d0ef66ddff - blender - Blender Projects
### Commit Details:
As discussed in
#105407
, it can be useful to support returning
a fallback value specified by the user instead of failing the driver
if a driver variable cannot resolve its RNA path. This especially
applies to context variables referencing custom properties, since
when the object with the driver is linked into another scene, the
custom property can easily not exist there.

This patch adds an optional fallback value setting to properties
based on RNA path (including ordinary Single Property variables
due to shared code and similarity). When enabled, RNA path lookup
failures (including invalid array index) cause the fallback value
to be used instead of marking the driver invalid.

A flag is added to track when this happens for UI use. It is
also exposed to python for lint type scripts.

When the fallback value is used, the input field containing
the property RNA path that failed to resolve is highlighted in red
(identically to the case without a fallback), and the driver
can be included in the With Errors filter of the Drivers editor.
However, the channel name is not underlined in red, because
the driver as a whole evaluates successfully.

#110135
-------
,
Manual
### Commit Summary: Drivers Panel - Blender 4.1 Manual
### Commit Details:
Drivers Panel
#
Edit Driver popover.
#
Reference
Editor
:
Graph editor
Mode
:
Drivers
Panel
:
Sidebar region ‚Ä£ Drivers
Shortcut
:
N
Reference
Menu
:
Context menu ‚Ä£ Edit Driver
Shortcut
:
Ctrl
-
D
This panel is visible in Sidebar of the
Drivers Editor
or as a popover when adding a driver to a property.
It shows the property that is being driven, followed by a series of settings
that determine how the driver works.
Driver Settings
#
Type
#
There are two categories of drivers:
Built-in functions
(
Average
,
Sum
,
Min
and
Max
)
The driven property will have the value of the average, sum, lowest or highest (respectively)
of the values of the referenced
Driver Variables
.
If there is only one driver variable, these functions will yield the same result.
Custom
(
Scripted Expression
).
An arbitrary Python expression that can refer to the
Driver Variables
by name. See
Expressions
.
Driver Value
#
The current result of the driver setup. Useful for debug purposes.
Variables
#
See
Driver Variables
.
Update Dependencies
#
Forces an update for the Driver Value dependencies.
Show in Drivers Editor
#
Opens the fully featured
Drivers Editor
.
This button only appears in the popover version of the Drivers panel.
Driver Variables
#
Variables are references to properties, transformation channels, or the result of a comparison
between transformations of two objects.
Drivers should access object data via
Driver Variables
, rather than direct references in the Python expression,
in order for dependencies to be correctly tracked.
Add, Copy, Paste buttons.
#
Add Input Variable
Adds a new Driver Variable.
Copy/Paste Variables
Copies the current variable list so it can be pasted into another driver‚Äôs variable list.
Name
Name for use in scripted expressions.
The name must start with a letter, and only contain letters, digits, or underscores.
Variable Type
The type of variable to use.
Single Property
Retrieves the value of an RNA property, specified by a data-block reference and a path string.
In case of transform properties, this will return the exact value of the UI property,
while Transform Channel will take parenting and/or constraints into account as needed.
See also
Custom Properties
.
ID Type
The ID-block type. For example: Key, Image, Object, Material.
ID
The ID of the ID-block type. For example: ‚ÄúMaterial.001‚Äù.
RNA Path
The RNA name of the property, based on a subset of Python attribute access syntax.
For example:
location.x
or
location[0]
for the X location animation channel
value (before parenting or constraints), or
["prop_name"]
for a custom property.
Fallback
If enabled, allows specifying a fallback value to use as the variable value if the RNA Path cannot
be resolved, instead of causing a driver evaluation failure. For more info see
Context Property
below.
Tip
The easiest way to create a variable of this type is to use
the
Copy As New Driver
context menu option of the input property, and paste the result
into the driver via
Paste Driver Variables
.
Transform Channel
Retrieves the value of a Transform channel from an object or bone.
ID
ID of the object. For example: Cube, Armature, Camera.
Bone
For armatures, the name of the Armature bone. For example: ‚ÄúBone‚Äù, ‚ÄúBone.002‚Äù, ‚ÄúArm.r‚Äù.
Type
For example, X Location, X Rotation, X Scale.
The
Average Scale
option retrieves the combined scale value,
computed as the cubic root of the total change in volume.
Unlike
X/Y/Z Scale
, this value can be negative if the object is flipped by negative scaling.
Mode (Rotation)
For rotation channels, specifies the type of rotation data to use, including
different explicit
Euler
orders. Defaults to using the Euler order of
the target. See
Rotation Channel Modes
.
Space
World Space, Transform Space, Local Space.
Rotational Difference
Provides the value of the rotational difference between two objects or bones, in radians.
Bone
For armatures, the name of the Armature bone. For example: ‚ÄúBone‚Äù, ‚ÄúBone.002‚Äù, ‚ÄúArm.r‚Äù.
Distance
Provides the value of the distance between two objects or bones.
Bone
For armatures, the name of the Armature bone. For example: ‚ÄúBone‚Äù, ‚ÄúBone.002‚Äù, ‚ÄúArm.r‚Äù.
Space
World Space, Transform Space, Local Space.
Context Property
Provides the value of a property that is implicitly referring to either a scene
or a view layer of the currently evaluating animation system.
This is a weak reference which does not lead to the scene or view layer
referenced from the driver to be linked when linking animation data.
An example when such properties comes in play is referring to a transformation
of the active camera. It is possible to set up a driver in a character file,
and make the driver use the set camera when the character is linked into a set.
Context
Active Scene, Active View Layer.
RNA Path
The RNA name of the property, based on a subset of Python attribute access syntax.
For example:
camera.location.x
or
camera.location[0]
for the camera X location animation
channel value (before parenting or constraints), or
["prop_name"]
for a custom property.
Fallback
If enabled, allows specifying a fallback value to use as the variable value if the RNA Path cannot
be resolved, instead of causing a driver evaluation failure.
This feature can be very useful for making drivers more robust when implementing scene-global options
using custom properties. When the object is linked into a different scene, these custom properties may
not exist there, and the fallbacks can be used to provide sensible default values.
Fallbacks can also be used to
emulate
the lookup behavior of the View Layer mode of the material
Attribute Node
.
Tip
Although the values of the x/y/z animation channels for the camera location can be accessed
via
camera.location[0/1/2]
, retrieving its world space location and orientation after parenting
and constraints currently requires using
camera.matrix_world
. This property can be understood
easily by viewing the matrix as an array of four vectors in
World
space:
matrix_world[0][0/1/2]
is the
Screen Right
direction vector (camera local X).
matrix_world[1][0/1/2]
is the
Screen Up
direction vector (camera local Y).
matrix_world[2][0/1/2]
is the
opposite
of the direction the camera is pointing.
matrix_world[3][0/1/2]
is the
location
of the camera.
Value
Shows the value of the variable.
Rotation Channel Modes
#
Rotation Transform Channels support a number of operation modes, including:
Auto Euler
Uses the
Euler
order of the target to decompose rotation into channels.
XYZ Euler, ‚Ä¶
Explicitly specifies the
Euler
rotation order to use.
Quaternion
Provides the
Quaternion
representation of the rotation.
Swing and X/Y/Z Twist
Decomposes the rotation into two parts: a
Swing
rotation that aims the specified
axis in its final direction, followed by a
Twist
rotation around that axis.
This is often necessary for driving corrective
Shape Keys
and bones for organic joint rotation.
This decomposition is often produced in rigs by using a helper bone with
a
Damped Track Constraint
to extract the swing part, and its child with
Copy Transforms
to extract the twist component.
The channels values for
Swing and Y Twist
are:
Falloff curves for weighted angles.
#
Y Rotation
True angle of the twist rotation.
W Rotation
True angle of the swing rotation, independent of its direction.
X Rotation, Z Rotation
Weighted angles that represent the amount of swing around the X/Z axis.
The magnitude of the angle equals
W Rotation
when the rotation is purely around
that axis, and fades out to zero as the direction changes toward the other axis,
following the falloff curves from the graph on the right.
Mathematically, the swing angles are computed from quaternion components,
using
\(2 \arccos(w)\)
for
W
and
\(2 \arcsin(x)\)
etc. for the others.
The component of the swing rotation that corresponds to the twist axis is always 0,
and is replaced by the twist angle.
Expressions
#
Expression
A text field where you can enter an arbitrary Python expression that refers to
Driver Variables
by their names.
The expression has access to a set of standard constants and math functions from
math
,
bl_math
and other modules, provided in the
Driver Namespace
. For an example of adding
a custom function to the namespace, see the
driver namespace example
.
For performance reasons it is best to use the
Simple Expressions
subset as much as possible.
Use Self
If this option is enabled, the variable
self
can be used for drivers to reference their own data.
Useful for objects and bones to avoid having creating a
Driver Variable
pointing to itself.
Example:
self.location.x
applied to the Y rotation property of the same object
will make the object tumble when moving.
Note that dependencies for properties accessed via
self
may not be fully tracked.
Simple Expressions
#
Blender can evaluate a useful subset of Python driver expressions directly,
which significantly improves performance, especially on multi-core systems.
To take advantage of this, the driver expression must only use the following features:
Variable Names
Use only ASCII characters.
Literals
Floating-point and decimal integer.
Globals
frame
Constants
pi
,
True
,
False
Operators
+
,
-
,
*
,
/
,
==
,
!=
,
<
,
<=
,
>
,
>=
,
and
,
or
,
not
, conditional operator/ ternary if
Standard Functions
min
,
max
,
radians
,
degrees
,
abs
,
fabs
,
floor
,
ceil
,
trunc
,
round
,
int
,
sin
,
cos
,
tan
,
asin
,
acos
,
atan
,
atan2
,
exp
,
log
,
sqrt
,
pow
,
fmod
Blender Provided Functions
lerp
,
clamp
,
smoothstep
Simple expressions are evaluated even when Python script execution is disabled.
When an expression outside of this subset is used, Blender displays a ‚ÄúSlow Python expression‚Äù
warning. However, as long as the majority of drivers use simple expressions, using a complex
expression in select few is OK.
See also
Extending Blender with Python
.
Python
and its
documentation
.
functions.wolfram.com
.
-------
)
Drivers that failed to evaluate are now underlined in red
  in the channel list of the Driver Editor.
  Previously that only happened for drivers attached to non-existing properties.
  (
b9074381e5
### Commit Summary: Drivers Editor: apply red underline to drivers that failed evaluation. ¬∑ b9074381e5 - blender - Blender Projects
### Commit Details:
F-Curves with a broken rna path are highlighted with a red underline
in the channel list of the animation editors. I think it makes sense
to also apply this to drivers that failed to evaluate and were disabled.

Otherwise, it is not apparent which drivers are broken without checking
every one manually, or applying the errors filter.
-------
)
Graph Editor
¬∂
Scale from Neighbor operator (
b27718a9e7
### Commit Summary: Anim: Graph Editor Scale From Neighbor ¬∑ b27718a9e7 - blender - Blender Projects
### Commit Details:
Combination of two operators by Ares Deveaux
#106524
and
#106523
Introduces a new operator "Scale from Neighbor"
that scales selected keyframe segments from either
the left or right keyframe neighbor.

Pressing "D" during modal operation will switch
from which end of the segment the scaling happens.

This is useful to make a section of animation closer to a pose on either side.

Co-authored-by: Ares Deveaux
#112387
-------
,
Manual
### Commit Summary: Editing - Blender 4.1 Manual
### Commit Details:
Editing
#
Transform
#
Reference
Mode
:
Edit Mode
Menu
:
Key ‚Ä£ Transform
An F-Curve can be edited by transforming the locations of the keyframes.
Move, Rotate, Scale
Like other elements in Blender, keyframes can be
moved, rotated, or scaled as described in
Basic Transformations
.
Extend
Moves keyframes relative to the current frame.
If the mouse is to the left of the Playhead,
this operator only affects the selected keyframes that are to the left of the Playhead.
On the contrary, if the mouse is to the right of the Playhead,
this operator only affects the selected keyframes that are to the right of the Playhead.
Tip
For precise control of the keyframe position and value,
you can set values in the
Active Keyframe
of the Sidebar region.
Snap
#
Reference
Menu
:
Key ‚Ä£ Snap
Shortcut
:
Shift
-
S
Keyframes can be snapped to different properties by using the
Snap Keys
tool.
Selection to Current Frame
Snap the selected keyframes to the current frame.
Selection to Cursor Value
Snap the selected keyframes to the
2D Cursor
.
Selection to Nearest Frame
Snap the selected keyframes to their nearest frame individually.
Selection to Nearest Second
Snap the selected keyframes to their nearest second individually, based on the
FPS
of the scene.
Selection to Nearest Marker
Snap the selected keyframes to their nearest marker individually.
Flatten Handles
Flatten the
B√©zier
handles for the selected keyframes.
Flatten Handles snapping example.
#
Before Flatten Handles.
#
After Flatten Handles.
#
Equalize Handles
Ensure selected keyframes‚Äô handles have equal length.
Side
Side of the keyframes‚Äô B√©zier handles to affect
Left
:
Equalize selected keyframes‚Äô left handles.
Right
:
Equalize selected keyframes‚Äô right handles.
Both
:
Equalize both of a keyframe‚Äôs handles.
Handle Length
Length to make selected keyframes‚Äô B√©zier handles.
Flatten
Make the values of the selected keyframes‚Äô handles the same as their respective keyframes.
Cursor to Selected
Ctrl
-
G
Places the cursor at the midpoint between selected keyframes.
Cursor Value to Selection
Places the cursor value on the average value of selected keyframes.
Mirror
#
Reference
Menu
:
Key ‚Ä£ Mirror
Shortcut
:
Ctrl
-
M
Selected keyframes can be mirrored over different properties using the
Mirror Keys
tool.
By Times over Current Frame
Mirror horizontally over the current frame.
By Values over Cursor Value
Mirror vertically over the 2D cursor.
By Times over Time 0
Mirror horizontally over frame 0.
By Values over Value 0
Mirror vertically over value 0.
By Times over First Selected Marker
Mirror horizontally over the first selected marker.
Jump to Selected
#
Reference
Menu
:
Key ‚Ä£ Jump to Selected
Shortcut
:
Ctrl
-
G
Places the 2D cursor at the center of the selected keyframes.
Insert
#
Reference
Menu
:
Key ‚Ä£ Insert
Shortcut
:
I
Inserts a keyframe to the active F-Curve at the mouse position.
The newly added keyframes will be selected, making it easier to quickly tweak the newly added keyframes.
All previously selected keyframes are kept selected by using
I
.
Type
All Channels
:
Insert a keyframe on all visible and editable F-Curves using each curve‚Äôs current value.
Only Selected Channels
:
Insert a keyframe on selected F-Curves using each curve‚Äôs current value.
Only Active F-Curve
:
Insert a keyframe on the active F-Curve using the curve‚Äôs current value.
Active Channels at Cursor
:
Insert a keyframe for the active F-Curve at the cursor point.
Selected Channels at Cursor
:
Insert a keyframe for selected F-Curves at the cursor point.
Copy/Paste
#
Reference
Menu
:
Key ‚Ä£ Copy
,
Key ‚Ä£ Paste
Shortcut
:
Ctrl
-
C
,
Ctrl
-
V
Use
Ctrl
-
C
to copy selected keyframes and
Ctrl
-
V
to paste the previously copied keyframes.
During the paste action, the
Adjust Last Operation
panel provides some options in
how the paste is applied.
Frame Offset
No Offset
:
Pastes the keyframes in the location they were copied from.
Frame Relative
:
Pastes the keyframe relative to the current frame based on the locations of
the keyframes relative to the current frame when they were copied.
Frame Start
:
Pastes the keyframes with the first keyframe of the copied set placed at the current frame.
Frame End
:
Pastes the keyframes with the last keyframe of the copied set placed at the current frame.
Value Offset
No Offset
:
Pastes the keyframes with the value they were copied from.
Cursor Value
:
Paste the keyframes at the 2D cursor as a starting point.
Current Frame Value
:
Paste keyframes relative to the value of the curve under the cursor.
Right Key
:
Paste keyframes such that the last frame matches the key value right of the cursor.
Left Key
:
Paste keyframes such that the first key matches the key value left of the cursor.
Type
Mix
:
Integrates the pasted keyframes in with existing keyframes only overwriting keyframes that share a frame.
Overwrite All
:
Removes all previous keyframes and replaces them with the pasted keyframes.
Overwrite Range
:
Overwrite keys in pasted range.
Overwrite Entire Range
:
Overwrite keys in pasted range, using the range of all copied keys.
Flipped
Paste keyframes from mirrored bones if they exist.
Duplicate
#
Reference
Menu
:
Key ‚Ä£ Duplicate
Shortcut
:
Shift
-
D
Duplicates the selected keyframes. You can reposition them by moving the mouse.
Delete
#
Reference
Menu
:
Key ‚Ä£ Delete
Shortcut
:
X
,
Delete
Pressing
X
or
Delete
opens a pop-up menu from where you can delete the selected keyframes.
Handle Type
#
Reference
Menu
:
Key ‚Ä£ Handle Type
Shortcut
:
V
Sets the
handle type
of the selected keyframes.
Interpolation Mode
#
Reference
Menu
:
Key ‚Ä£ Interpolation Mode
Shortcut
:
T
Sets the
interpolation mode
between the selected keyframes.
Easing Type
#
Reference
Menu
:
Key ‚Ä£ Easing Type
Shortcut
:
Ctrl
-
E
Sets the
easing mode
of the selected keyframes.
Density
#
Decimate
#
Reference
Menu
:
Key ‚Ä£ Density ‚Ä£ Decimate (Ratio)
Menu
:
Key ‚Ä£ Density ‚Ä£ Decimate (Allowed Change)
The
Decimate
tool simplifies an F-Curve by removing
keyframes that influence the curve shape the least.
Mode
Controls which method is used pick the number of keyframes to use.
Ratio
:
Deletes a defined percentage of keyframes,
the amount of keyframes to delete is define by the
Remove
property.
Error Margin
:
Deletes keyframes which only allowing the F-Curve to change by a defined amount.
The amount of change is controlled by the
Max Error Margin
which controls how much the new decimated curve is allowed to deviate from the original.
Bake Keyframes
#
Reference
Menu
:
Key ‚Ä£ Density ‚Ä£ Bake Keyframes
Shortcut
:
Shift
-
Alt
-
O
Baking a set of keyframes replaces interpolated values with a new keyframe for each frame.
F-Curve before baking.
#
F-Curve after baking.
#
Clean Keyframes
#
Reference
Menu
:
Key ‚Ä£ Density ‚Ä£ Clean Keyframes
Shortcut
:
X
Removes redundant keys within the selection of keyframes.
Clean Keyframes
resets the keyframe tangents on selected keyframes
to their auto-clamped shape, if they have been modified.
Tip
The modified curve left after the
Clean
tool is run is not the same as the original,
so this tool is better used before doing custom editing of F-Curves and after initial keyframe insertion,
to get rid of any unwanted keyframes inserted while doing mass keyframe insertion
(by selecting all bones and pressing
I
for instance).
Channels
Operate on selected channels and cleans them regardless of keyframe selection.
Deletes the channel itself if it is only left with
a single keyframe containing the default property value and
it‚Äôs not being used by any generative F-Curve modifiers or drivers.
F-Curve before cleaning.
#
F-Curve after cleaning.
#
Blend
#
Reference
Menu
:
Key ‚Ä£ Blend
Shortcut
:
Alt
-
D
Breakdown
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Breakdown
Moves the selected keyframes to an in between position relative to the adjacent keyframes.
To use this operator, drag the mouse left or right to adjust the operator‚Äôs
Factor
property.
Factor
The amount to favor either the left or the right key. Values less than 0.5 favor the left keyframe,
values greater than 0.5 favor the right keyframe, a value of 0.5 results in no change.
Blend to Neighbor
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Blend to Neighbor
Transitions the current keyframe with the neighboring keyframes in the timeline.
In order for this operator to work, there must be a keyframe before and after the current frame.
To use this operator, drag the mouse left or right to adjust the operator‚Äôs
Blend
property.
Blend
The amount to favor either the left or the right key. Values less than 0.5 favor the left keyframe,
values greater than 0.5 favor the right keyframe, a value of 0.5 results in no change.
Blend to Default Value
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Blend to Default Value
Transitions the current keyframe towards the property‚Äôs default value.
To use this operator, drag the mouse left or right to adjust the operator‚Äôs
Blend
property.
Blend
The amount to favor either the current key or the default value.
A value of 0 represents the current key, a value of 1 represents the default value.
See also
The
Reset to Default
operator resets
any property to its default value without the need of keyframing.
Ease
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Ease
Aligns selected keyframes to follow an exponential path between the first and last keyframes.
To use this operator, drag the mouse left or right to adjust the operator‚Äôs
Blend
property.
Blend
Changes the concavity of the curve. Values less than 0.5 cause keyframes to concave up,
values greater than 0.5 cause keyframes to concave down, a value of 0.5 results in a straight line.
Blend Offset
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Blend Offset
Move the selected keyframes as a block so the first/last key align with the key before/after the selection.
Does nothing when there is no key before/after the current selection.
Offset Factor
At -1 the first key of the selection is aligned with the key just before the selection.
At 1 the last key is aligned with the key after the selection.
Blend to Ease
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Blend to Ease
Blend the selected keys from their current position to either an ease in or an ease out curve.
Blend
At -1 the keys will start slowly and then accelerate to the end.
At 1 the keys will rise quickly and then taper off.
Match Slope
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Match Slope
Blend the selected keys to a straight line formed by the two keys just outside the current selection.
The factor determines if the two keys left or right of the selection are used. If there are not
two keys in the given direction the operator will throw a warning and not change the keys.
Factor
Determines which slope to blend towards. At -1 will blend to the left slope, at 1 to the right.
Shear Keys
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Shear Keys
Shear the keys based on the position of the keyframe selection ends.
Pressing
D
while the modal operator is active will toggle the anchor key
between the start and end of the selection.
Shear Factor
How much to shear and if it shears up or down. Negative values shear down, positive shear up.
Direction
From Left
or
From Right
determine the anchor key from which to shear.
Scale Average
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Scale Average
Scale the selected key segments to their average value. This differs from the regular scaling by being per segment.
That means selected keyframes on two different F-Curves will scale to different points.
Factor
The scale factor applied to the F-Curve segments.
Scale from Neighbor
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Scale from Neighbor
Scale the selected key segments from either their left or right neighbor key. Pressing
D
while in the modal
operator switches the reference key from one end to the other.
Factor
The scale factor applied to the F-Curve segments.
Reference Key
From Left
or
From Right
determine from which end of the segment to scale.
Push Pull
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Push Pull
Scale the keys from an imaginary line that runs from the start to the end of the selected segment.
Factor
How far to push or pull the keys.
Time Offset
#
Reference
Menu
:
Key ‚Ä£ Blend ‚Ä£ Time Offset
This operator shifts the value of the keys in time, while keeping the actual key positions in the same place. It
supports wrapping, so when offsetting beyond the range of the F-Curve it will take values from the other end, but
offset in y-value so there is no jump. This works best with dense key data. Gaps in the keyframe data might cause data
to get lost if it is shifted into the gaps.
Frame Offset
How far in frames to offset the animation.
Smooth
#
Reference
Menu
:
Key ‚Ä£ Smooth
Shortcut
:
Alt
-
S
Smooth (Legacy)
#
Reference
Menu
:
Key ‚Ä£ Smooth ‚Ä£ Smooth (Legacy)
Shortcut
:
Alt
-
O
There is also an option to smooth the selected curves, but beware: its algorithm seems to be
to divide by two the distance between each keyframe and the average linear value of the curve,
without any setting, which gives quite a strong smoothing! Note that the first and last keys
seem to be never modified by this tool.
F-Curve before smoothing.
#
F-Curve after smoothing.
#
Smooth (Gaussian)
#
Reference
Menu
:
Key ‚Ä£ Smooth ‚Ä£ Smooth (Gaussian)
Smooths the selected keyframes using a Gaussian kernel. It can handle gaps in the keyframe data.
The operator is modal with a blend factor, making it possible to tweak the strength of the filter.
Factor
A blend factor from original to filtered curve.
Sigma
The shape of the gaussian distribution. Lower values mean a sharper curve, giving keys that are close to each
other more weight. A high value behaves like a simple average filter.
Filter Width
A wider filter looks at more keyframes, producing a smoother result.
At a size of 1 the filter only looks at the keyframes to the immediate left and right for a weighted average.
F-Curve after applying the Gaussian Smooth with the original curve overlayed.
#
Butterworth Smooth
#
Reference
Menu
:
Key ‚Ä£ Smooth ‚Ä£ Butterworth Smooth
Smooth the selected keyframes using a Butterworth filter. This filter is ideal for
smoothing large amounts of data because it preserves the peaks of the animation.
The downside is that it can introduce a ripple effect when the key values change rapidly.
Frequency Cutoff
The lower the value the smoother the curve. There is an implicit maximum at which
the value no longer changes the curve which is at half the sample rate. The sample
rate in this case is the scene frame rate multiplied by the
Samples per Frame
of this operator.
Filter order
Higher values mean the frequency cutoff is steeper.
Samples per Frame
Before the filter is applied, the curve is resampled at this interval to avoid errors when there
are uneven spaces between frames. If keys are on subframes, e.g. a 60fps file in a 30fps scene,
increase this value to 2.
Blend
A 0-1 value to blend from original curve to filtered curve.
Blend In/Out
The number of frames at the start and end for which to blend between the filtered and unfiltered curve.
This can help reducing jumps in the animation at the selection border. At value 1 it only locks the first and
last frame of the selection to the original position.
-------
)
Add an option to automatically lock key movement to either the X or Y axis.
  This can be found under
View
¬ª
Auto-Lock Axis
.
  (
446b92d2ce
### Commit Summary: Anim: Graph Editor - automatically lock key translation to a single axis ¬∑ 446b92d2ce - blender - Blender Projects
### Commit Details:
When moving keys in the Graph Editor animators
usually only want to move them on one axis.
While this is possible in a few ways (G+X, or G + Middle Mouse Button click),
we could default the behavior to always lock on an axis.
This was suggested by Dreamworks animators during the
Animation & Rigging module meeting.
https://devtalk.blender.org/t/2024-01-26-animation-rigging-module-meeting/33081#patch-review-decision-time-5
This PR adds an option with which the movement is
always locked to a single axis by default.
The option can be found in the Graph Editor under "View->Auto-Lock Axis".

The movement will then be restricted to the axis along
which you've moved the cursor the most.
You can still manually override the lock behavior by pressing `X` or `Y`.

I am piggybacking off the auto locking feature you get when pressing the middle mouse button.
When the new feature is enabled I call that at the start of the transformation.
Except when:
* only handles are selected
* the tweak mode has been started on a handle

This is to not snap handles, which is a behavior that has
been requested by the artists.

#117669
-------
)
Add option to right click menu on animated properties to view the
  FCurve that animates it. For this to work the object/node has to be selected.
  (
a91a8f3fed
### Commit Summary: Anim: View FCurve of Property in the Graph Editor ¬∑ a91a8f3fed - blender - Blender Projects
### Commit Details:
This commit adds a new operator that allows to view an FCurve in the Graph Editor from the animated property.

# Features
* Frame a single property or a whole array property by right-clicking an animated property
* Works on a property anywhere in blender
* Framed FCurves are selected and set to visible
* Works on the selection. If an object/bone doesn't have a property it is ignored.
* Works with NLA offset and normalization
* Isolate curves. This is a property on the operator

# Caveats
* Frames on the first Graph Editor it finds
* Since it works on the selection but the n-panel works on the active object,
you can create a situation where nothing happens because you can have
an active object without it being selected.
* Assigning a shortcut doesn't work through right clicking the menu entry.
You have to go to the keymap and create a new entry manually (e.g. in the user interface category)

#114407
-------
,
Manual
### Commit Summary: Introduction - Blender 4.1 Manual
### Commit Details:
Introduction
#
The Graph Editor allows users to adjust animation curves over time for any animatable property.
F-Curves
.
The Graph Editor.
#
Main Region
#
The curve view allows you to view and edit F-Curves.
An F-Curve has several key parts:
Curve
The curve defines the value (Y axis) of the property over time (X axis).
See
F-Curves
.
Keyframes
Keyframes are user-defined values on certain frames and are represented
by little black squares which become orange if selected.
See
Keyframes
for more information.
Handles
Each keyframe has a handle that helps determine the values of the curve between keyframes.
These handles are represented by extruding lines with circular ends
and can be selected and modified to change the shape of the curve.
See
F-Curve Handles
for more information.
A simple curve.
#
See also
See
F-Curves
for more info.
Navigation
#
As with most editors, you can:
Pan
Pan the view vertically (values) or horizontally (time) with click and drag
MMB
.
Zoom
Zoom in and out with the mouse wheel
Wheel
.
Scale View
Scale the view vertically or horizontally
Ctrl
-
MMB
.
In addition, you can also use the scrollbars to pan and zoom the view.
Tip
You can frame an F-Curve channel from any animated property by right clicking on it and choosing
View in Graph
Editor
. In order to bind that function to a hotkey, you need to make a hotkey manually in the e.g. User Interface
category. Using the right click menu won‚Äôt work as it would be in the wrong category.
The operator name is
anim.view_curve_in_graph_editor
.
Playhead & 2D Cursor
#
Graph Editor 2D Cursor.
#
The current frame is represented by a blue vertical line called the
Playhead
.
As in the
Timeline
,
you can change the current frame by
LMB
-dragging in the scrubbing area at the top of the editor.
The blue horizontal line is called the
2D Cursor
.
This can be enabled or disabled via the
View Menu
or the
View Properties
panel.
These two lines can be used as a reference for moving and scaling keyframe handles.
See also
See Graph Editor‚Äôs
View Tab
.
View Axes
#
For
Actions
the X axis represents time,
the Y axis represents the value to set the property.
Depending on the selected curves, the values have different meaning:
for example rotation properties are shown in degrees.
Header
#
View Menu
#
Sidebar
N
Show or hide the
Sidebar Region
.
Adjust Last Operation
Displays a pop-up panel to alter properties of the last
completed operation. See
Adjust Last Operation
.
Channels
Show or hide the
Channels Region
.
Frame Selected
NumpadPeriod
Reset viewable area to show selected keyframes.
Frame All
Home
Reset viewable area to show all keyframes.
Go to Current Frame
Numpad0
Centers the area to the Playhead.
Realtime Updates
When transforming keyframes, changes to the animation data are propagated to other views.
Show Sliders
A toggle option that shows the value sliders for the channels.
See the Fig.
The Action editor‚Äôs channels region.
.
Auto-Merge Keyframes
Automatically merge nearby keyframes.
Auto-Lock Key Axis
Automatically locks the movement of keyframes to the dominant axis.
Show Markers
Shows the markers region. When disabled, the
Markers Menu
is also hidden
and markers operators are not available in this editor.
Show Cursor
Toggles the visibility of the
Playhead & 2D Cursor
.
Show Seconds
Ctrl
-
T
Show timing in seconds not frames.
Sync Visible Range
It synchronizes the horizontal panning and scale of the current editor
with the other editors (Graph, Dope Sheet, NLA, and Sequencer) when this option is set.
That way you always have these editors showing the same section of frames.
Show Extrapolation
Toggles the visibility of the
extrapolated
portion of curves.
Show Handles
Ctrl
-
H
Toggles the display of a curve‚Äôs handles in the curve view.
Only Selected Keyframes Handles
Only shows the handles for the currently selected curves.
Set Preview Range
P
Interactively define frame range used for playback.
Allows you to define a temporary preview range to use for animation playback
(this is the same thing as the
Playback Range
option of
the
Timeline editor header
).
Clear Preview Range
Alt
-
P
Clears the preview range.
Set Preview Range to Selected
Ctrl
-
Alt
-
P
Automatically select the preview range based on the range of keyframes.
Toggle Dope Sheet
Changes the area‚Äôs editor to the
Dope Sheet
.
Area
Area controls, see the
user interface
documentation for more information.
See also
See Graph Editor‚Äôs
View Tab
.
See Timeline‚Äôs
View Menu
.
Select Menu
#
All
A
Selects all keyframes and handles.
None
Alt
-
A
Clears all selected items.
Invert
Selects all unselected items and unselects any currently selected items.
Box Select
B
Selects items inside the defined box.
Box Select (Axis Range)
Todo.
Box Select (Include Handles)
Selects keyframes and their handles inside the defined box.
Circle Select
C
Selects keyframe points using circle selection.
Lasso Select
Selects keyframe points using lasso selection.
Columns on Selected Keys
K
Selects all other keyframes that are on the same frame as the selected keyframes.
Column on Current Frame
Ctrl
-
K
Selects all other keyframes that are on the same frame as the current frame.
Columns on Selected Markers
Shift
-
K
Selects all other keyframes that are on the same frame as the selected
Markers
.
Between Selected Markers
Alt
-
K
Selects all keyframes that are between the first and last
Markers
as they fall in the timeline.
Before Current Frame
Select keyframes to the left of the current frame.
After Current Frame
Select keyframes to the right of the current frame.
Select Handles
Selects the associated handles to the currently selected keyframes.
Select Keys
Selects the associated keyframes to the currently selected handles.
Select More/Less
Selects/deselects keyframes in close proximity to currently selected keyframes.
Select Linked
Select keyframes occurring in the same F-Curves as selected ones.
Markers Menu
#
Markers
are used to denote frames with key points or significant events
within an animation. Like with most animation editors, markers are shown at the bottom of the editor.
Markers in animation editor.
#
For descriptions of the different marker tools see
Editing Markers
.
View Controls
#
View controls.
#
Show Only Selected
Only include curves related to the selected objects and data.
Show Hidden
Include curves from objects/bones that are not visible.
Show Only Errors
Only include curves and drivers that are disabled or have errors.
Useful for debugging.
Filter (funnel icon)
Only include curves with keywords contained in the search field.
Type Filter
Filter curves by property type.
Filtering Collection
Select a collection to only show keyframes from objects contained in that collection.
Sort Data-Blocks
Objects data-blocks appear in alphabetical order, so that it is easier to find where they occur
(as well as helping to keep the animation of related objects together in the NLA for instance).
If you find that your playback speed suffers from this being enabled
(it should only really be an issue when working with lots of objects in the scene),
you can turn this off.
Normalize
Normalize curves so the maximum or minimum point equals 1.0 or -1.0.
When enabled, the view scales to fit the normalized curves and the outer range is darkened.
If a preview range is defined, keyframes within the range are normalized, while the rest is scaled proportionally.
Auto
Automatically recalculate curve normalization on every curve edit.
This is useful to prevent curves from jumping after tweaking it.
Create Ghost Curves (framed F-Curve icon)
Creates a picture with the current shape of the curves.
Transform Controls
#
Transform controls.
#
Pivot Point
Pivot point for rotation.
Bounding Box Center
:
Center of the selected keyframes.
2D Cursor
:
Center of the
2D Cursor
.
Playhead
+
Cursor
.
Individual Centers
:
Rotate the selected keyframe
B√©zier
handles.
Snap
Activates automatic snapping when you moving keys.
Snap To
Type of element to snap to.
Frame
:
Snap to frame.
Second
:
Snap to seconds.
Nearest Marker
:
Snap to nearest
Marker
.
Absolute Time Snap
Absolute time alignment when transforming keyframes
Proportional Editing
O
See
Proportional Editing
.
Sidebar Region
#
The panels in the
Sidebar region
.
View Tab
#
View Tab.
#
Show Cursor
Toggles the visibility of the
2D Cursor
.
Cursor X, Y
Moves the cursor to the specified frame (X value) and value (Y value).
Cursor to Selection
Places the
2D Cursor
at the midpoint of the selected keyframes.
See also
Graph Editor‚Äôs
View Menu
.
Further Tabs
#
F-Curve Tab
See
F-Curve
.
Modifiers Tab
See
F-Curve Modifiers
.
-------
)
Demo of viewing the F-Curve of the animated property
F-Curve Baking
¬∂
A new operator "Bake Channels" has been added to the Graph Editor.
(
1e931f5bd7
### Commit Summary: Anim: Bake Channel operator ¬∑ 1e931f5bd7 - blender - Blender Projects
### Commit Details:
This is a replacement for the workflow that uses
"Bake Curve" and "Unbake Curve" to quickly generate
dense key data.

Compared to the existing workflow it has the advantage
of allowing the user more control over the key types,
and distance between keys, as well as the frame range affected.

Operator options

* Range: the range that will be baked.
Defaults to the scene range or preview range.

* Step: Distance between keyframes.
Can be used to bake on 2s or even bake to subframes.

* Remove Existing Keys: Boolean option that
if enabled also removes keys outside the specified baking range

* Interpolation Type: Choose a interpolation mode used
for new keys e.g. Constant or Bezier

* Bake Modifiers: If enabled bakes the effect of the
modifier stack to keys and deletes the modifier stack.
If false, the code disables the modifiers before baking,
so the resulting keys will behave as if the modifiers didn't exist

The operator can be found in the Graph Editor under `Channel->Bake Channels`

Part of:
#111050
#111263
-------
,
Manual
### Commit Summary: Editing - Blender 4.1 Manual
### Commit Details:
Editing
#
Delete Channels
#
Reference
Menu
:
Channel ‚Ä£ Delete Channels
Shortcut
:
X
Deletes the whole channel from the current action
(i.e. unlink the underlying F-Curve data-block from this action data-block).
Warning
The
X
shortcut is area-dependent: if you use it in the left list part,
it will delete the selected channels, whereas if you use it in the main area,
it will delete the selected keyframes.
Un/Group Channels
#
Reference
Menu
:
Channel ‚Ä£ Un/Group Channels
Shortcut
:
Ctrl
-
Alt
-
G
,
Ctrl
-
G
Un/Groups the selected channels into a collection that can be renamed by double clicking on the group name.
For example, this helps to group channels that relate a part of an armature to keep the editor more organized.
Toggle/Enable/Disable Channel Settings
#
Reference
Menu
:
Channel ‚Ä£ Toggle/Enable/Disable Channel Settings
Shortcut
:
Shift
-
W
,
Shift
-
Ctrl
-
W
,
Alt
-
W
Enable/disable a channel‚Äôs setting (selected in the menu that pops up).
Protect, Mute
Todo.
Toggle Channel Editability
#
Reference
Menu
:
Channel ‚Ä£ Toggle Channel Editability
Shortcut
:
Tab
Locks or unlocks a channel for editing.
Extrapolation Mode
#
Reference
Menu
:
Channel ‚Ä£ Extrapolation Mode
Shortcut
:
Shift
-
E
Change the extrapolation between selected keyframes.
Extrapolation defines the behavior of a curve before the first and after the last keyframes.
There are two basic extrapolation modes:
Constant
:
Constant extrapolation.
#
The default one, curves before their first keyframe and after their last one have a constant value
(the one of these first and last keyframes).
Linear
:
Linear extrapolation.
#
Curves ends are straight lines (linear), as defined by the slope of their first and last keyframes.
Additional extrapolation methods (e.g. the
Cycles
modifier)
are located in the
F-Curve Modifiers
.
Add F-Curve Modifier
#
Reference
Menu
:
Channel ‚Ä£ Add F-Curve Modifier
Shortcut
:
Shift
-
Ctrl
-
M
Opens a pop-up allowing you to add modifiers to the active F-Curve.
Settings for the
modifier
can be found in
the
Sidebar ‚Ä£ Modifiers
tab.
Show/Hide
#
Hide Selected Curves
H
Hides the selected curves.
Hide Unselected
Shift
-
H
Show only the selected curve (and hide everything else).
Reveal Curves
Alt
-
H
Show all previous hidden curves.
Expand/Collapse Channels
#
Reference
Menu
:
Channel ‚Ä£ Expand/Collapse Channels
Shortcut
:
NumpadPlus
,
NumpadMinus
Expands or collapses selected channels.
Move
#
Reference
Menu
:
Channel ‚Ä£ Move‚Ä¶
This allows you to move selected channels up/down
PageUp
,
PageDown
,
or directly to the top/bottom
Shift
-
PageUp
,
Shift
-
PageDown
.
Revive Disabled F-Curves
#
Reference
Menu
:
Channel ‚Ä£ Revive Disabled F-Curves
Clears ‚Äúdisabled‚Äù tag from all F-Curves to get broken F-Curves working again.
Frame Selected Channels
#
Reference
Menu
:
Channel ‚Ä£ Frame Selected Channels
Shortcut
:
NumpadPeriod
Reset viewable area to show the selected channels.
To frame the channel that is under the mouse cursor, use
Alt
-
MMB
.
Include Handles
Include handles of keyframes when calculating extents.
Use Preview Range
Ignore frames outside of the preview range.
Keys to Samples
#
Reference
Menu
:
Channel ‚Ä£ Keys to Samples
Shortcut
:
Alt
-
C
This operator replaces an F-Curve with a set of sampled points at each full frame.
It is a destructive process that removes the ability to edit the curve
.
The main use for this is to reduce the file size with large datasets. Samples are only 1/5th the size per key.
The sampled points interpolate linearly on subframes.
Samples to Keys
#
Reference
Menu
:
Channel ‚Ä£ Samples to Keys
This operator replaces a sampled F-Curve with keyframes, adding the ability to edit it.
It will not recreate the curve as it was before, instead it will place 1 key at every frame.
Sound to Samples
#
Reference
Menu
:
Channel ‚Ä£ Sound to Samples
The
Sound to Samples
operator takes a sound file and uses its sound wave to create the animation data.
By default this data will not be editable, use
Samples to Keys
to get editable keyframes.
Lowest Frequency
Cutoff frequency of a high-pass filter that is applied to the audio data.
Highest Frequency
Cutoff frequency of a low-pass filter that is applied to the audio data.
Attack Time
Value for the hull curve calculation that tells how fast the hull curve can rise.
The lower the value the steeper it can rise.
Release Time
Value for the hull curve calculation that tells how fast the hull curve can fall.
The lower the value the steeper it can fall.
Threshold
Minimum amplitude value needed to influence the hull curve.
Accumulate
Only the positive differences of the hull curve amplitudes are summarized to produce the output.
Additive
The amplitudes of the hull curve are summarized. If
Accumulate
is enabled,
both positive and negative differences are accumulated.
Square
Gives the output as a square curve.
Negative values always result in -1, and positive ones in 1.
Square Threshold
All values lower than this threshold result in 0.
Bake Channels
#
Reference
Menu
:
Channel ‚Ä£ Bake Channels
The
Bake Channels
operator creates new keyframes on the F-Curves of channels that are selected in the channel box.
Range
The range that will be baked. Defaults to the scene range or preview range.
Step
Distance between keyframes. Can be used to bake on 2s or even bake to subframes.
Remove Existing Keys
Boolean option that if enabled also removes keys outside the specified baking range.
Interpolation Type
Choose which interpolation type new keys should have, e.g. Constant or Bezier.
Bake Modifiers
If true bakes the effect of the modifier stack to keys and deletes the modifier stack.
If false, modifiers get disabled before baking, so the resulting keys will behave as if the modifiers didn‚Äôt exist.
Discontinuity (Euler) Filter
#
Reference
Menu
:
Channel ‚Ä£ Discontinuity (Euler) Filter
This operator cleans up Euler rotation channels that suffer from
Gimbal Lock
.
The channels of all three axes of euler rotation need to be selected for the operator
to work.
-------
)
It allows you to:
Specify a range to bake.
Define the distance between baked keys, e.g. 2s or 3s.
Remove keys outside the baked range.
Define a interpolation type for new keyframes.
Bake modifiers to keyframes.
It is found in the Graph Editor under
Channel
¬ª
Bake Channels
.
Dope Sheet
¬∂
Speed up Dope Sheet by only calculating keyframes that are visible in
  the current view.
  (
f06fd85d97
### Commit Summary: Anim: Restrict range of fcurve_to_keylist ¬∑ f06fd85d97 - blender - Blender Projects
### Commit Details:
# Issue
Having a lot of keys in your scene can dramatically slow down the Dope Sheet.
That is because everytime the Dope Sheet is redrawn,
the Keylists have to be recomputed.
In the case of the summary channel, that means going through
all keyframes of all the `FCurves` and adding them to the keylist.
That eats up 95% of the time it takes to draw a frame.

# This PR
It's not a perfect solution, rather it solves the performance issue
for the case when you are not displaying all keys.
Instead of going through all the keys, only add the
keys visible in the view to the keylist.
This speeds up the Dope Sheet significantly
depending on the zoom level.

This also improves the responsiveness when selecting and transforming keyframes.

# Performance changes

The function measured is `ED_channel_list_flush`
which is responsible for building the keylists and drawing them.
The test setup contains 62 bones with all
10 channels keyed (location, rot quaternion, scale) on 6000 frames.
So 3.720.000 keys. The heavier the dataset the bigger the performance impact.

The data was recorded with only the Dope Sheet open, and 3 channels visible
* Summary
* Object
* Action

The more channels are visible, the greater the performance gain. This can be seen in the video.

| visible range | before | after |
| - | - | - |
| 200f | 250ms | 10ms |
| 400f | 250ms | 18ms |
| 3000f | 250ms | 130ms |
| 6000f | 250ms | 250ms |

#114854
-------
)
Motion Paths
¬∂
Add an option to create motion paths relative to the active camera.
This means the motion paths will appear in screen space when looking through that camera.
(
79f84775f2
### Commit Summary: Anim: Motion Paths in camera space ¬∑ 79f84775f2 - blender - Blender Projects
### Commit Details:
Animators (especially for film and TV) often need
to track the movement of things in screenspace.
At the end of the day, the pixel motion is what counts.
But motion paths were always in world space,
which made it hard to use when the camera
is also animated (during action scenes e.g.)

This PR introduces the feature of projecting a motion path into the screen space of the active scene camera.

Limitations
This makes the motion path only useful when looking through the active scene camera.
Switching the scene camera using markers is not yet supported.

Technical Implementation
This is achieved by baking the motion path points into the
camera space on creation. For every point calculated,
the camera is evaluated through the depsgraph and
the resulting world matrix is used.
Then I pass in the current frame's world matrix of the
camera into the shader to make sure the points follow it.
As can be seen in the video, it looks quite odd when
viewed at another angle but this is expected.
I mentioned that in the tooltip, so it shouldn't be an issue

#117593
-------
)
Demo of motion paths in camera space

'''''


2. Blender 4.1: Compositor¬∂

Blender 4.1: Compositor
¬∂
Added
¬∂
Support was added to the
Viewport Compositor
for the following nodes:
Vector Blur (
e84dc990b1
### Commit Summary: Realtime Compositor: Implement Vector Blur node ¬∑ e84dc990b1 - blender - Blender Projects
### Commit Details:
This patch implements the Vector Blur node for the Realtime Compositor.
The implementation is a direct and mostly identical port of the EEVEE
motion blur implementation with the necessary adjustments to make it
work with the compositor.

The exposed parameters in the node does not match those exposed in
EEVEE, so only the parameters shared between both are currently
implemented. In the future, we should make a decision to either unify
both, or just consider them independent implementations, with the
possibility of sharing the full or part of the code.

Further, it would also make sense to port the implementation to the CPU
compositor, since the new implementation is higher in quality while also
being faster.

The default value of the node shutter setting was changed to 0.25 to
approximately match the default settings of EEVEE and Cycles, since in
their default settings, they evaluate the previous and next frames at
plus and minus 0.25.

#116977
-------
)
Defocus (
e055db6605
### Commit Summary: Realtime Compositor: Implement Defocus node ¬∑ e055db6605 - blender - Blender Projects
### Commit Details:
This patch implements the defocus node for the Realtime Compositor. The
implementation does not match the CPU compositor implementation, but
uses a new formulation that is more physically accurate and consistent
with Blender's render engines.

The existing CPU implementation is questionable starting from its circle
of confusion calculation, to the morphological operations applied on the
CoC radius, to ignoring the maximum CoC radius in the search kernel, and
ending with the threshold parameter used to reduce artifacts. Therefore,
it should be reimplemented along with this same implementation using a
more consistent methodology.

EEVEE and Workbench already have a GPU defocus method, which can be
ported to the compositor and used as the preview defocus algorithm.
While this implementation will be updated to be a more accurate method
that produces the same structure as the ported EEVEE implementation.

The new formulation ignores the threshold parameter for now, as well as
the preview parameter.

#116391
-------
)
Cryptomatte (
a8e13994b8
### Commit Summary: Realtime Compositor: Implement Cryptomatte node ¬∑ a8e13994b8 - blender - Blender Projects
### Commit Details:
This patch implements the Cryptomatte node for the Realtime Compositor.

#115884
-------
)
Keying Screen (
17bdf18397
### Commit Summary: Realtime Compositor: Implement Keying Screen node ¬∑ 17bdf18397 - blender - Blender Projects
### Commit Details:
This patch implements the Keying Screen node for the Realtime
Compositor. Draw data was introduced to the Movie Clip ID to allow
caching of the keying screen.

#113055
-------
)
This completes support for all nodes with the exception of passes in the Render Layers node,
which only supports Image, Alpha, and Depth passes.
A new
Split
node was added, which replaces the
Split Viewer
node with the exact same
  functionality, except it now provides its output as a node output. (
153f14be2b
### Commit Summary: Compositor: Make split viewer a regular split node ¬∑ 153f14be2b - blender - Blender Projects
### Commit Details:
Changes:
- Renamed Split Viewer Node to Split Node
- Split Node is now under `Utilities` (similar to Switch node)
- Versioning: split viewer from 4.0 and before is replaced with the new split node connected to a new viewer node.

#114245
-------
)
A new Size input to the Kuwahara node was added to allow variable sizing. Additionally, a new
High Precision
option was added to the node in the
Classic
mode, which produces more accurate
  results for high resolution and high dynamic range images. (
203559757a
### Commit Summary: Compositor: Allow variable size Kuwahara ¬∑ 203559757a - blender - Blender Projects
### Commit Details:
This patch changes the size property of the Kuwahara into a node socket
to allow variable size Kuwahara.

#112946
-------
,
e4a93d7b8c
### Commit Summary: Compositor: Add High Precision option to Kuwahara ¬∑ e4a93d7b8c - blender - Blender Projects
### Commit Details:
For high radii Kuwahara, we use a Summed Area Table (SAT) implementation
to accelerate the classic variant of the algorithm. The problem is that
due to limited floating point precision, the SAT can produce artifacts
in its output.

An attempt to fix this was implemented in
#114191
, and while that patch
improved precision by 10x, the artifacts still existed, albeit less
noticeable. But since the improved precision also meant a performance
penalty, it was decided that the improvement is not worth it.

Since the artifacts are only noticeable for scenes with very high
values, this patch adds a High Precision option that defaults to false
and can be enabled by the user upon noticing any artifacts. The option
simply uses direction convolution instead of SAT in this case. The
downside, of course, is that it can be orders of magnitude slower.

An alternative to using this option is for the user to clamp the input
or downsample the image. Both methods should be documented in the
documentation.
Fixes
:
#113578
.

#115763
-------
)
A new size property was added to the Pixelate node, which allows the node to be used without
  being surrounded by scale-down and scale-up nodes. (
baab14ca38
### Commit Summary: Compositor: Re-write Pixelate node for CPU compositor ¬∑ baab14ca38 - blender - Blender Projects
### Commit Details:
The old implementation was a simple rounding operation and was not
implemented for full-frame compositor.

The issue with the old implementation is that it will not give
satisfactory results for images with high frequency details,
including cases when is used for a preview on Cycles render with
low number of samples. Additionally, when applied on animated
footage it produces very noisy result.

The new algorithm uses an explicit pixel size setting, which allows
the node to be used on its own, without need to have scale-down and
scale-up nodes. It also uses neighbour averaging, which produces
better looking result during animation and noisy input images.

The old tiled compositor setup will render without changes with
this change. This commit does not include modifications in the GPU
compositor implementation.

Ref
#88150
#117223
-------
,
feb2d02709
### Commit Summary: Realtime Compositor: Rewrite Pixelate node ¬∑ feb2d02709 - blender - Blender Projects
### Commit Details:
This patch rewrites the pixelate node to average a window of a certain
pixel size, following the new CPU implementation.

#117243
-------
)
A new Precision option was added to the node tree options. It allows choosing between full
  precision and automatic precision, where the automatic option uses half precision for the
  viewport and interactive compositing. Half precision runs faster with less memory usage, albeit
  with reduced precision and value ranges. (
474b6fa070
### Commit Summary: Realtime Compositor: Support full precision compositing ¬∑ 474b6fa070 - blender - Blender Projects
### Commit Details:
This patch adds support for full precision compositing for the Realtime
Compositor. A new precision option was added to the compositor to change
between half and full precision compositing, where the Auto option uses
half for the viewport compositor and the interactive render compositor,
while full is used for final renders.

The compositor context now need to implement the get_precision() method
to indicate its preferred precision. Intermediate results will be stored
using the context's precision, with a number of exceptions that can use
a different precision regardless of the context's precision. For
instance, summed area tables are always stored in full float results
even if the context specified half float. Conversely, jump flooding
tables are always stored in half integer results even if the context
specified full. The former requires full float while the latter has no
use for it.

Since shaders are created for a specific precision, we need two variants
of each compositor shader to account for the context's possible
precision. However, to avoid doubling the shader info count and reduce
boilerplate code and development time, an automated mechanism was
employed. A single shader info of whatever precision needs to be added,
then, at runtime, the shader info can be adjusted to change the
precision of the outputs. That shader variant is then cached in the
static cache manager for future processing-free shader retrieval.
Therefore, the shader manager was removed in favor of a cached shader
container in the static cache manager.

A number of utilities were added to make the creation of results as well as
the retrieval of shader with the target precision easier. Further, a
number of precision-specific shaders were removed in favor of more
generic ones that utilizes the aforementioned shader retrieval
mechanism.

#113476
-------
)
A new Filter Type option was added to the
Map UV
node to allow the user to choose between
  Anisotropic filtering and Nearest Neighbour filtering. (
a3b7674c6e
### Commit Summary: Compositor: Add a Nearest sampling to Map UV node ¬∑ a3b7674c6e - blender - Blender Projects
### Commit Details:
When using the MapUV node for certain NPR workflows (for example palette
based remapping of colors) it can be useful to not use the default
anisotropic filtering.

In preparation of potentially adding more filter modes at a later stage
and to keep things consistent with the 'transform' node we use the full
set of interpolation modes in the enum, but expose only the implemented
ones in RNA..
-------
)
The Depth pass is now partially supported in the
Viewport Compositor
. It is only partially
  supported since it only works for EEVEE and Workbench, and it exposes the depth in normalized
  coordinates, instead of the typical linear format expected for depth passes. Using a
Normalize
node should make it more useful for the moment. (
c5eb420c74
### Commit Summary: Viewport Compositor: Allow access to depth pass ¬∑ c5eb420c74 - blender - Blender Projects
### Commit Details:
This patch allows access to the depth pass in the Viewport Compositor.

Since the depth information require full precision, making use of the
pass requires the full precision option for now. In the future, this
pass will always be stored using full precision regardless of the
precision option.
-------
)
Changed
¬∂
The
Keying Screen
node was changed to use a
Gaussian Radial Basis Function Interpolation
,
  which produces smoother temporally stable keying screens. The node now also have smoothness
  parameter to control the width of the interpolation. (
75c947a467
### Commit Summary: Compositor: Use RBF Interpolation in Keying Screen node ¬∑ 75c947a467 - blender - Blender Projects
### Commit Details:
This patch changes the interpolation algorithm utilized by the Keying
Screen node to a Gaussian Radial Basis Function Interpolation. This is
proposed because the current Voronoi triangulation based interpolation
has the following properties:

- Not temporally stable since the triangulation can abruptly change as
  tracking markers change position.
- Not smooth in the mathematical sense, which is also readily visible in
  the artists sense.
- Computationally expensive due to the triangulation and naive
  rasterization algorithm.

On the other hand, the RBF interpolation method is temporally stable and
continuous, smooth and infinitely differentiable, and relatively simple
to compute assuming low number of markers, which is typically the case
for keying screen objects.

This breaks backward compatibility, but the keying screen is only used
as a secondary input for keying in typical compositor setups, so one
should expect minimal difference in outputs.

#112480
-------
)
The
Inpaint
node was changed to use Euclidean distance instead of Manhattan distance, resulting
  in a more uniform filled regions. The node now also uses a two-pass algorithm that allows better
  smoothing for internal filling, as demonstrated in the following example.
  (
48d7d60c96
### Commit Summary: Realtime Compositor: Rewrite inpaint node ¬∑ 48d7d60c96 - blender - Blender Projects
### Commit Details:
This patch rewrites the Inpaint node in the Realtime Compositor. The old
method suffered from discontinuities and singularities in the inpainting
regions. Furthermore, it ignored semi-transparent areas.

The new method is inspired by a two pass method described by the paper:

  Rosner, Jakub, et al. "Fast GPU-based image warping and inpainting for
  frame interpolation." International Conferences on Computer Graphics,
  Vision and Mathematics. 2010.

In particular, we first fill the inpainting region using jump flooding,
then we apply a variable size blur pass whose size is proportional to
the distance to the inpainting boundary. The smoothed region is then
mixed with the input using its alpha.

The new method is much closer to the Bertalmio-style diffusion-based
inpainting methods, and thus can more accurately close holes than
existing methods.

The aforementioned method requires variable size blur, which is quite
expensive for this use case, so a new implementation was added that
approximates the method using a separable implementation, which provides
a visually pleasing result assuming a sufficiently smooth radius field,
which is true for our case since the field is an SDF.
Fixes
:
#114422
#114849
-------
)
The
Bilateral Blur
and
Bokeh Blur
nodes now assume extended image boundaries, that is, they
  assume pixels outside of the image boundary are the same color as their closest boundary pixels.
  While they previously ignored such pixels and adjusted blur weights accordingly.
  (
3d7e84f57d
### Commit Summary: Compositor: Unify Bilateral Blur across CPU and GPU ¬∑ 3d7e84f57d - blender - Blender Projects
### Commit Details:
This patch unifies the implementation of the Bilateral Blur node across
CPU and GPU. The difference is due to two things. First, the CPU code
had a bug where the upper limit of the blur window was not included in
the accumulation. Second, CPU ignored pixels outside of the image while
GPU clamped them to the nearest boundary pixel. The latter difference
was aligned with GPU until we eventually add an option to control
boundary handing.

A few utilities were added to the node operation and memory buffer
classes to do clamped pixel reading.

#117751
-------
,
a433adda8e
### Commit Summary: Compositor: Unify Bokeh Blur between CPU and GPU ¬∑ a433adda8e - blender - Blender Projects
### Commit Details:
This patch adjusts the Bokeh Blur node such that it matches between CPU
and GPU. The GPU implementation is followed for the reasons stated
below.

The first difference is a bug in the CPU implementation, where the upper
limit of the blur window is not considered, but the lower limit is.

The second difference is due to an additional weight of 1.0 for blur
size less than 2, which was apparently in place to workaround the
aforementioned bug, since for zero sized blurs, the blur loop will not
run due to the missing upper limit.

The third difference is due to CPU ignoring outside pixels instead of
clamping them to border, which is done until an option is added to the
node to control the boundary condition.

An extra difference existed between Tiled and Full-frame, where the
canvas had different rounding methods, so that was unified.

#117847
-------
)
The
Double Edge Mask
node now include the zero point of the gradient, while it previously
  started from the gradient value after zero. (
049b0e6539
### Commit Summary: Compositor: Rewrite and optimize Double Edge Mask node ¬∑ 049b0e6539 - blender - Blender Projects
### Commit Details:
This patch rewrites and optimizes the Double Edge Mask node to be orders
of magnitude faster. For a 1k complex mask, it is 650x faster, while for
a 1k simple mask, it is only 50x faster.

This improvement is attributed to the use of a new Jump Flooding
algorithm as well as multi-threading, matching the GPU implementation.

The result of the new implementation differs in that the boundaries of
the masks are now identified as the last pixels inside the mask.

#117545
-------
)
The
Flip
node now works in local space, which means flipping will not change the location of
  the image if it was translated. (
70a8a9e4d9
### Commit Summary: Compositor: make Flip node works in local space ¬∑ 70a8a9e4d9 - blender - Blender Projects
### Commit Details:
This patch changes the operation space of the Flip node from the global
space to the local space. This means that the Flip node will now flip
the image without changing its location.
-------
)
The
Crop
node no longer flips its bounds if they were inverted, which means that if the upper
  bound was less than the lower bound, the node will crop the image to nothing.
  (
4bf08198a7
### Commit Summary: Compositor: Do not flip bounds of Crop node ¬∑ 4bf08198a7 - blender - Blender Projects
### Commit Details:
The Crop node currently flips its bounds if the lower bound is larger
than the higher bound, which is not a good design. Instead, clamp the
bounds.
-------
)
Scaling and Rotation in the Viewport Compositor are now immediately realized, which means scaling
  up an image will now actually produce more pixels, and that applying filters on rotated images
  will work as expected, instead of being applied along the direction of rotation.
  (
e592763940
### Commit Summary: Realtime Compositor: Immediately realize transformations ¬∑ e592763940 - blender - Blender Projects
### Commit Details:
This patch immediately realizes the scale and rotation components of
transformations at the point of transform nodes. The translate component is
still delayed and only realized when really needed to avoid clipping.

Transformed results are always realized in an expanded domain that avoids
clipping due to rotation or scaling. The size of the transformed domain is
clipped to the GPU texture size limit for now until we have support for huge
textures, that limit is typically 16k.

A potential optimization is to join all consecutive transform and realize
operations into a single realize operation.
Fixes
#112332
.

#112332
-------
)
Translations in the Viewport Compositor are now immediately realized for the axes that has
  enabled wrapping. Consequently, the image will not get translated, but its content will, in a
  clip on one side, wrap on the opposite side manner. Further, wrapping information is no longer
  propagated to future automatic realizations, so tilling or repeating an image is no longer
  possible. An alternative method of repetition will be introduced in a later patch.
  (
1500a594ad
### Commit Summary: Realtime Compositor: Immediately realize wrapped translations ¬∑ 1500a594ad - blender - Blender Projects
### Commit Details:
This patch changes how wrapped translations are handled by the Realtime
Compositor. Previously, translations were always stored on the result
and delayed until automatically realized later. The wrapping status was
also stored to control this later automatic realization.

This patch changes that such that translations are immediately realized
for the axes that has enabled wrapping. Consequently, the image will not
get translated, but its content will, in a clip on one side, wrap on the
opposite side manner.

Another change is that wrapping information is no longer propagated to
future automatic realizations, so tilling or repeating an image is no
longer possible. An alternative method of repetition will be introduced
in a later patch.

#113669
-------
)
Improved
¬∂
The Viewport Compositor now cache multi-pass images, making multi-pass compositing much faster.
  (
356480fabb
### Commit Summary: Realtime Compositor: Add static cached images ¬∑ 356480fabb - blender - Blender Projects
### Commit Details:
The Realtime compositor currently relies on the GPU cache in image IDs.
That cache only supports single layer images, so multi-layer images will
be acquired without a cache, introducing significant IO bottlenecks for
the GPU compositor.

This patch ignores the image GPU cache and stores the images in the
static cache manager of the compositor. Draw data was introduced to the
image ID for proper cache invalidation, like other IDs such as masks.

The downside is that the cache will no longer be shared between EEVEE
and the compositor. But realistically, images are not typically shared
between materials and compositors.

This is just a temporary solution until we have proper GPU storage
support for image buffers.

#115511
-------
)
The
Double Edge Mask
node is now orders of magnitude faster. (
049b0e6539
### Commit Summary: Compositor: Rewrite and optimize Double Edge Mask node ¬∑ 049b0e6539 - blender - Blender Projects
### Commit Details:
This patch rewrites and optimizes the Double Edge Mask node to be orders
of magnitude faster. For a 1k complex mask, it is 650x faster, while for
a 1k simple mask, it is only 50x faster.

This improvement is attributed to the use of a new Jump Flooding
algorithm as well as multi-threading, matching the GPU implementation.

The result of the new implementation differs in that the boundaries of
the masks are now identified as the last pixels inside the mask.

#117545
-------
)
The
Z Combine
and
Dilate
nodes now use an improved Anti-Aliasing algorithm.
  (
1aafb6802b
### Commit Summary: Compositor: Use SMAA for anti-aliasing in all nodes ¬∑ 1aafb6802b - blender - Blender Projects
### Commit Details:
This patch changes all anti-aliasing operations to use SMAA instead of
the Scale3x-based operation. That's because SMAA is more accurate while
the Scale3x one is more a hack.
-------
)
The
Defocus
node now uses a more accurate method to compute the bokeh radius, so results should
  now match render engines better. (
65e1a3a5c3
### Commit Summary: Compositor: Port redesigned Defocus node to CPU ¬∑ 65e1a3a5c3 - blender - Blender Projects
### Commit Details:
This patch ports the redesigned GPU Defocus node to the CPU.

#117174
-------
)
The
Sun Beams
node now produces smoother results. (
cbb738191e
### Commit Summary: Compositor: Redesign Sun Beams node for CPU ¬∑ cbb738191e - blender - Blender Projects
### Commit Details:
This patch ports the new GPU implementation of the Sun Beams node to the
CPU compositor. Introduced in
9e358fcd44
.
-------
)
The compositor now only executes if its result is really used or viewed.
  (
e165624885
### Commit Summary: Compositor: Only execute compositor if result is viewed ¬∑ e165624885 - blender - Blender Projects
### Commit Details:
This patch makes it such that the compositor only executes when its
result is viewed either through the backdrop or through an image editor.

#116326
-------
)
Removed
¬∂
The
Split Viewer
node was removed, replaced by the
Split
node. (
153f14be2b
### Commit Summary: Compositor: Make split viewer a regular split node ¬∑ 153f14be2b - blender - Blender Projects
### Commit Details:
Changes:
- Renamed Split Viewer Node to Split Node
- Split Node is now under `Utilities` (similar to Switch node)
- Versioning: split viewer from 4.0 and before is replaced with the new split node connected to a new viewer node.

#114245
-------
)

'''''


3. Blender 4.1: Cycles¬∂

Blender 4.1: Cycles
¬∂
OpenImageDenoise GPU Acceleration
¬∂
OpenImageDenoise is now GPU accelerated on supported hardware.
This makes full quality denoising available at interactive rates in the 3D viewport.
(
#115045
)
It is enabled automatically when using GPU rendering in the 3D viewport.
It can be disabled in the denoising settings panel,
to reduce GPU memory usage at the cost of slower denoising.
Supported GPUs
¬∂
NVIDIA GTX 16xx, TITAN V and all RTX GPUs
Intel GPUs with Xe-HPG architecture or newer
Apple Silicon with macOS version 13.0 and newer
For AMD GPUs, it is currently not enabled due to stability issues. However it can be tested in
daily Blender 4.2 LTS builds
.
There it is supported for AMD RDNA2 and RDNA3 generation discrete GPUs.
Benchmark
¬∂
The denoising time of the Junkshop scene on various devices in seconds (lower is better):
Denoising time on various devices
Device
Time (seconds)
Apple M2 Ultra CPUL
1.035
Apple M2 Ultra GPU (76 Cores)
0.293
Intel i9-13900k
1.224
Intel Arc A770
0.067
NVidia RTX 3090
0.078
Other
¬∂
Option to disable bump map correction
  (
36e603c430
### Commit Summary: Cycles: Add option to control smoothing when using bump map ¬∑ 36e603c430 - blender - Blender Projects
### Commit Details:
Cycles implements the "Taming the Shadow Terminator" paper by Matt Jen-Yuan
Chiang to solve shadow terminator issues when a bump map is applied, as well
as similar approach for the glossy reflection to ensure ray does not get
reflected to inside of the object.

This correction term is applied unconditionally, which makes it harder to have
full control over shading via normals for stylistic reasons.

This change exposes this corrective term as an option called "Bump Map
Correction" which is available in the shader settings next to the
"Transparent Shadows".

The reason to make it per-shader rather than per-object is to allow flexibility
of a control: it is possible that an object has multiple shaders attached to it,
and only some of them used for bump mapping. Another, and possibly stronger
reason to have it per-shader is ease of assets control: shader brings settings
which are needed for its proper behavior. So if material at some point
decides to take over normals, artists would not need to update settings on
every asset which uses that material.

The option is enabled by default, so there is no changes for existing setups.

#113480
-------
)
AMD GPU rendering support added for RDNA3 generation APUs
  (
d19ad12b45
### Commit Summary: Cycles: add support for AMD RDNA3 APUs ¬∑ d19ad12b45 - blender - Blender Projects
### Commit Details:
#113696
-------
)
Linux CPU rendering performance was improved by about 5% across benchmarks
  (
PR#116663
)

'''''


4. Blender 4.1: EEVEE¬∂

Blender 4.1: EEVEE
¬∂
Light Probes
¬∂
Probe types have been renamed:
Reflection Cubemap to Sphere
Reflection Plane to Plane
Irradiance Grid to Volume

'''''


5. Blender 4.1: Geometry Nodes¬∂

Blender 4.1: Geometry Nodes
¬∂
Baking
¬∂
The
Bake
can save and load data from inside node groups so that its inputs
  don't have to be recomputed (
00eaddbd51
### Commit Summary: Geometry Nodes: new Bake node ¬∑ 00eaddbd51 - blender - Blender Projects
### Commit Details:
This adds a new `Bake` node which allows saving and loading intermediate geometries.
Typical use cases we want address with this currently are:
* Bake some data for use with a render engine.
* Bake parts of the node tree explicitly for better performance.

For now, the format that is written to disk is not considered to be an import/export format.
It's not guaranteed that data written with one Blender version can be read by another
Blender version. For that it's better to use proper interchange formats. Better support for
those will be added eventually as well. We also plan an `Import Bake` node that allows
reading the blender-specific baked data independent of the Bake node and at different frames.

The baking works very similar to the baking in the simulation zone (UI and implementation
wise). Major differences are:
* The Bake node has a `Bake Still` and `Bake Animation` mode.
* The Bake node doesn't do automatic caching.

Implementation details:
* Refactored how we create the Python operators for moving socket items so that it also
  makes sense for non-zones.
* The `ModifierCache` stores an independent map of `SimulationNodeCache` and
  `BakeNodeCache`, but both share a common data structure for the actually baked data.
* For baking, the `Bake` node is added as a side-effect-node in the modifier. This will make
  sure that the node is baked even if it's currently not connected to the output.
* Had to add a new `DEG_id_tag_update_for_side_effect_request` function that is used
  during baking. It's necessary because I want to evaluate the object again even though none
  of its inputs changed. The reevaluation is necessary to create the baked data. Using
  `DEG_id_tag_update` technically works as well, but has the problem that it also uses the
  `DEG_UPDATE_SOURCE_USER_EDIT` flag which (rightly) invalidates simulation caches
  which shouldn't happen here.
* Slightly refactored the timeline drawing so that it can also show the baked ranges of
  Bake nodes. It does not show anything for baked nodes with a in Still mode though.
* The bake operator is refactored to bake a list of `NodeBakeRequest` which makes the
  code easier to follow compared to the previous nested
  `ObjectBakeData > ModifierBakeData > NodeBakeData` data structure.
* The bake operators are disabled when the .blend file is not yet saved. This is technically
  only necessary when the bake path depends on the .blend file path but seems ok to force
  the user anyway (otherwise the bake path may be lost as well if it's set explicitly).
* The same operators are used to bake and delete single bakes in `Bake` nodes and
  `Simulation Zones`. On top of that, there are separate operators of baking and deleting all
  simulation bakes (those ignore bake nodes).
* The `Bake` node remembers which inputs have been fields and thus may be baked as attributes.
  For that it uses an `Is Attribute` flag on the socket item. This is needed because the baked data
  may still contain attribute data, even if the inputs to the bake node are disconnected.
* Similar to simulation zones, the behavior of `Bake` nodes is passed into the geometry nodes
  evaluation from the outside (from the modifier only currently). This is done by providing the
  new `GeoNodesBakeParams` in `GeoNodesCallData` when executing geometry nodes.

Next Steps (mostly because they also involve simulations):
* Visualize nodes that have not been evaluated in the last evaluation.
* Fix issue with seemingly loosing baked data after undo.
* Improve error handling when baked data is not found.
* Show bake node in link drag search.
* Higher level tools for managing bakes.

#115466
-------
)
  (
manual
### Commit Summary: Bake Node - Blender 4.1 Manual
### Commit Details:
Bake Node
#
The
Bake
node allows saving and loading intermediate geometries.
This node bakes parts of the node tree for better performance.
The data format used to store geometry data is not considered to be an import/export format.
Volume objects, however, are saved using the OpenVDB file format which can be used interoperably.
Important
Blend-files must be saved to a disk before data can be baked.
It‚Äôs not guaranteed that data written with one Blender version can be read by another Blender version.
Inputs
#
Geometry
Standard geometry input, which is used as the default bake item.
More bake items can be added by dragging sockets into the blank socket or in the
Bake Items
panel.
Bake Items
#
Reference
Editor
:
Geometry Node Editor
Panel
:
Sidebar ‚Ä£ Node ‚Ä£ Bake Items
The
Bake Items
panel is used to manage the input sockets
of the node thus also managing what data is baked.
Bake Items List
Used to manage the inputs and outputs of the bake node.
Items can be added, removed, renamed, and sorted.
Socket Type
The data (
Sockets
) of the input/output.
Attribute Domain
The
attribute domain
used to evaluate the input field on.
Is Attribute
Bake item is an attribute stored on a geometry.
Properties
#
Note
Some properties can only be edited in the Properties panel
(
Sidebar ‚Ä£ Node ‚Ä£ Properties
).
Bake Mode
The
Bake
node can calculate the geometry of a single frame or an animation.
Animation
:
Bakes the geometry data for multiple frames.
By default the scene frame range is used, however, a
Custom Range
can also be defined.
Still
:
Bakes the geometry data of the current frame.
Bake
Preforms all necessary geometry calculations and saves the data to disk.
Delete (Trash Icon)
Deletes the bake data.
Custom Path
Specify a path where the baked data should be stored manually.
Bake Path
Location on disk where the baked data is stored.
Note, this path is also used for
simulation zones
.
Custom Range
Animation
Override the simulation frame range from the scene.
Start, End
The start and end frame numbers for the custom range.
Outputs
#
For each input, the same output is added to act as a pass through.
Geometry
Standard geometry output, which is used as the default bake item.
More bake items can be added by dragging sockets into the blank socket or in the
Bake Items
panel.
-------
).
The bake node and simulation baking can save references to geometry materials
  (
2d2b087fcf
### Commit Summary: Geometry Nodes: support baking data block references ¬∑ 2d2b087fcf - blender - Blender Projects
### Commit Details:
With this patch, materials are kept intact in simulation zones and bake nodes
without any additional user action.

This implements the design proposed in
#108410
to support referencing
data-blocks (only materials for now) in the baked data. The task also describes
why this is not a trivial issue. A previous attempt was implemented in
#109703
but it didn't work well-enough.

The solution is to have an explicit `name (+ library name) -> data-block`
mapping that is stored in the modifier for each bake node and simulation zone.
The `library name` is necessary for it to be unique within a .blend file. Note
that this refers to the name of the `Library` data-block and not a file path.
The baked data only contains the names of the used data-blocks. When the baked
data is loaded, the correct material data-block is looked up from the mapping.

### Automatic Mapping Generation

The most tricky aspect of this approach is to make it feel mostly automatic.
From the user point-of-view, it should just work. Therefore, we don't want the
user to have to create the mapping manually in the majority of cases. Creating
the mapping automatically is difficult because the data-blocks that should
become part of the mapping are only known during depsgraph evaluation. So we
somehow have to gather the missing data blocks during evaluation and then write
the new mappings back to the original data.

While writing back to original data is something we do in some cases already,
the situation here is different, because we are actually creating new relations
between data-blocks. This also means that we'll have to do user-counting. Since
user counts in data-blocks are *not* atomic, we can't do that from multiple
threads at the same time. Also, under some circumstances, it may be necessary to
trigger depsgraph evaluation again after the write-back because it actually
affects the result.

To solve this, a small new API is added in `DEG_depsgraph_writeback_sync.hh`. It
allows gathering tasks which write back to original data in a synchronous way
which may also require a reevaluation.

### Accessing the Mapping

A new `BakeDataBlockMap` is passed to geometry nodes evaluation by the modifier.
This map allows getting the `ID` pointer that should be used for a specific
data-block name that is stored in baked data. It's also used to gather all the
missing data mappings during evaluation.

### Weak ID References

The baked/cached geometries may have references to other data-blocks (currently
only materials, but in the future also e.g. instanced objects/collections).
However, the pointers of these data-blocks are not stable over time. That is
especially true when storing/loading the data from disk, but also just when
playing back the animation. Therefore, the used data-blocks have to referenced
in a different way at run-time.

This is solved by adding `std::unique_ptr
` to the
run-time data of various geometry data-blocks. If the data-block is cached over
a longer period of time (such that material pointers can't be used directly), it
stores the material name (+ library name) used by each material slot. When the
geometry is used again, the material pointers are restored using these weak name
references and the `BakeDataBlockMap`.

### Manual Mapping Management

There is a new `Data-Blocks` panel in the bake settings in the node editor
sidebar that allows inspecting and modifying the data-blocks that are used when
baking. The user can change what data-block a specific name is mapped to.

#117043
-------
).
Baked data-block references can be managed in the "Data-Block References" panel
  of the node editor sidebar.
Duplicate data in bakes is deduplicated more effectively, resulting in much smaller
  bake files in cases with identical geometry or attributes
  (
586fadd6d2
### Commit Summary: Geometry Nodes: deduplicate arrays in baked data ¬∑ 586fadd6d2 - blender - Blender Projects
### Commit Details:
This adds hash-based data deduplication when baking in
geometry nodes. All arrays that are written to `.blob` files
are hashed. If an array is detected to have the same hash
as a previously written array, it is not written again. Instead
the same memory is reused.

We already have a similar optimization, but that only worked .with data that was already implicitly shared. Doing this kind
of deduplication with implicitly shared data has the benefit,
that the equality check is constant time. The hash based
approach implemented here requires linear time in the size
of the array, but works on all kinds of data. Both optimizations
work together. So the hashing is skipped if possible.

The hash-based deduplication primarily benefits cases where
the data is regenerated on each frame, so the data between .frames is not shared. One example  used to require 2.9 GB
disk space. Now it only requires 542 MB. Additionally, the
duplicate arrays will now be implicitly shared between frames
when reading the baked data later.

An extended version of this approach which also detects partial
duplicates is implemented in
#117749
.

#117768
-------
).
Volumes can be baked as part with simulation nodes or the bake node
  (
444e148976
### Commit Summary: Geometry Nodes: support baking volume geometry ¬∑ 444e148976 - blender - Blender Projects
### Commit Details:
This adds support for baking the volume component of a geometry. Previously,
volumes were just removed in the simulation and bake node.

On disk, each volume geometry is written to a separate `.vdb` file that is stored in
the bakes `blobs` directory and referenced from the corresponding meta `.json` file.

Technically, it would also be easy to write the volume data to the same `.blob`
files that we also write e.g. mesh attributes to. However, since `.vdb` is a well
known file format, it seems reasonable to just store it as a separate file. The
serialization code doesn't really care whether it's a separate file or embedded into
a bigger file, so this decision could be made at a higher level.

Just like with other geometry types, materials are preserved. Just note that when
using the written stand-alone .vdb files, materials are not preserved.

Currently, volume grids are not deduplicated on disk. This could be added in the
future if necessary.

#117781
-------
).
Bake caches are no longer lost after undo
  (
7bb1ce1241
### Commit Summary: Geometry Nodes: improve handling baked data after undo ¬∑ 7bb1ce1241 - blender - Blender Projects
### Commit Details:
Previously, one could easily "loose" baked data by undoing. The data was not
actually deleted, but Blender didn't find it anymore. This happened because
`update_existing_bake_caches` was expected to be called after changes to
`NodesModifierData.bakes`. However, this was not called after undo.
It was also not possible to call this function from `blend_read`, because it
required access to the referenced node tree.

Now, the bake cache is lazily created during depsgraph evaluation, which
partially solves the problem. It can still seem that Blender lost data, but that
fixes itself much more quickly after the next evaluation. The remaining issue
should be solved a future patch that keeps the bake cache intact over undo
steps using `foreach_cache`.
-------
).
Nodes
¬∂
The
Musgrave Texture
node was
replaced by an extended Noise
  Texture node
.
The
Menu Switch
node allows creating custom "enum" menus to
  allow switching between options in the group interface
  (
5ad49f4142
### Commit Summary: Geometry Nodes: Menu Switch Node ¬∑ 5ad49f4142 - blender - Blender Projects
### Commit Details:
This patch adds support for _Menu Switch_ nodes and enum definitions in
node trees more generally. The design is based on the outcome of the
[2022 Nodes Workshop](
https://code.blender.org/2022/11/geometry-nodes-workshop-2022/#menu-switch
).

The _Menu Switch_ node is an advanced version of the _Switch_ node which
has a customizable **menu input socket** instead of a simple boolean.
The _items_ of this menu are owned by the node itself. Each item has a
name and description and unique identifier that is used internally. A
menu _socket_ represents a concrete value out of the list of items.

To enable selection of an enum value for unconnected sockets the menu is
presented as a dropdown list like built-in enums. When the socket is
connected a shared pointer to the enum definition is propagated along
links and stored in socket default values. This allows node groups to
expose a menu from an internal menu switch as a parameter. The enum
definition is a runtime copy of the enum items in DNA that allows
sharing.

A menu socket can have multiple connections, which can lead to
ambiguity. If two or more different menu source nodes are connected to a
socket it gets marked as _undefined_. Any connection to an undefined
menu socket is invalid as a hint to users that there is a problem. A
warning/error is also shown on nodes with undefined menu sockets.

At runtime the value of a menu socket is the simple integer identifier.
This can also be a field in geometry nodes. The identifier is unique
within each enum definition, and it is persistent even when items are
added, removed, or changed. Changing the name of an item does not affect
the internal identifier, so users can rename enum items without breaking
existing input values. This also persists if, for example, a linked node
group is temporarily unavailable.

#113445
-------
).
The
Split to Instances
node allows separating a geometry into
  multiple pieces based on a group ID
  (
5bee6bcedc
### Commit Summary: Geometry Nodes: new Split to Instances node ¬∑ 5bee6bcedc - blender - Blender Projects
### Commit Details:
This node allows splitting up a geometry into groups. A group is defined as all
elements with the same group id. The output contains an instance per group.
The `Group ID` output can be used for further deterministic processing.

The node supports meshes, curves, point clouds and instances. It only works
on the top-level geometry, so it does not go into nested instances because it
also generates new instances.

Co-authored-by: Hans Goudey
#113083
-------
).
The
Index Switch
node allows choosing between an arbitrary
  number of inputs with an index
  (
8d5aa6eed4
### Commit Summary: Geometry Nodes: Index switch node ¬∑ 8d5aa6eed4 - blender - Blender Projects
### Commit Details:
Add an "Index Switch" node which is meant as a simpler version of
the "Menu Switch" from
#113445
that doesn't allow naming items
or displaying them in a dropdown, but still allows choosing between
an arbitrary number of items, unlike the regular "Switch" node.
Even when the Menu Switch is included (which should be in the
same release as this), it may still be helpful to have explicit mapping
of indices, and a fair amount of the internals can be shared anyway.

#115250
-------
).
The
Sort Elements
node allows reordering geometry elements
  based on some sort key.
  (
37b2c12cfa
### Commit Summary: Geometry Nodes: Sort Elements node ¬∑ 37b2c12cfa - blender - Blender Projects
### Commit Details:
Implements the design in
#109983
#114194
-------
).
The
Fill Curve
node now has a "Group ID" input to limit filling to
  specific curve groups
  (
90de0368cd
### Commit Summary: Geometry Nodes: Add a Group ID input to the Fill Curve node ¬∑ 90de0368cd - blender - Blender Projects
### Commit Details:
This adds a "Group ID" input to the Fill Curve node, per
#102285
.

The curve filling operation is performed separately for each group,
so curves associated with different Group IDs do not intersect.

This implementation also supports Grease Pencil 3 curves.

Co-authored-by: Hans Goudey
#114048
-------
).
Node tools are now supported in object mode
  (
3fcd9c9425
### Commit Summary: Geometry Nodes: Support node tools in object mode ¬∑ 3fcd9c9425 - blender - Blender Projects
### Commit Details:
Extend node tools to display tool assets in object mode as well
as edit and sculpt modes. For consistency with existing Blender
design, selection cannot be set and is just "true" in object mode
because it can't be visualized. The visibility of tools can be
customized per object type in object mode as well.

See
#101778
#114819
-------
).
The
Rotate Rotation
node replaces the
Rotate Euler
node as a
  faster and clearer way to modifier rotations
  (
f4867c0d70
### Commit Summary: Geometry Nodes: Add Rotate Rotation node ¬∑ f4867c0d70 - blender - Blender Projects
### Commit Details:
This is meant as a replacement for the Rotate Euler node. Overall it
should be more performant, and the clarity given by the separate socket
type should help distinguish its purpose.

The Rotate Euler node is removed from search and the add menu by this
commit. In the future it can be versioned away. That isn't done now to
avoid a breaking API change and to make this commit less risky.

#116106
-------
).
Five nodes have been changed to use the rotation socket introduced in
  the last release
  (
600a133521
### Commit Summary: Geometry Nodes: Convert four nodes to use rotation socket ¬∑ 600a133521 - blender - Blender Projects
### Commit Details:
Convert the vector socket from four nodes to a rotation socket, adding
versioning to insert the conversion nodes and change the default values
where necessary.
- Distribute Points on Faces
- Instance on Points
- Rotate Instances
- Transform Geometry

Implicit conversions from vectors and floats, and to vectors have been
added, though using rotation sockets directly can be faster, since converting
to and from Euler rotations is slow. Conversion nodes are not inserted
by versioning if the implicit conversions can be used.

This change is not forward compatible with 3.6, and socket values
are lost when opening 4.1 files in 4.0. The correct socket types are
added back in old versions, though newly added conversion nodes
may have to be removed.

#111482
-------
,
49087a84d0
### Commit Summary: Geometry Nodes: Use rotation socket for the object info node ¬∑ 49087a84d0 - blender - Blender Projects
### Commit Details:
See
600a133521
and
#92967
.
-------
).
Distribute Points on Faces
Instance on Points
Rotate Instances
Transform Geometry
Object Info
Instance Rotation
The
Active Camera
input node gives the scene's current camera
  object
  (
75f160ee96
### Commit Summary: Geometry Nodes: Add Active Camera input node ¬∑ 75f160ee96 - blender - Blender Projects
### Commit Details:
This adds a new "Active Camera" input geometry node, per
#105761
.

The node outputs the the scene's current active camera. It is available
from Input > Scene > Active Camera in the geometry nodes Add menu.

Typical usage would be to connect this node to an Object Info node to
obtain its transform. This works as expected when the camera's
transform is animated, and also when there are markers on the timeline
that change the active camera.

In order to support the aforementioned changes in the active camera,
this implementation adds depsgraph relations for all cameras referenced
by timeline markers. This eliminates the complexity of updating the
depsgraph whenever the scene switches to a different active camera,
but of course it comes at the cost of including more objects than
strictly necessary in the depsgraph for scenes that switch cameras.
Dynamically updating the depsgraph upon camera changes could be a
future improvement if there proves to be sufficient need for it.

#113431
-------
).
The
Set Curve Normal
node now has the ability to set free ("custom")
  normals (
f63a7c1ee9
### Commit Summary: Curves: Add basic custom normals support ¬∑ f63a7c1ee9 - blender - Blender Projects
### Commit Details:
Add a new normal mode called "Custom" which directly interpolates
a "custom_normal" attribute to the evaluated points for the final
normal. Extend the "Set Curve Normal" node with this mode and
give it the ability to set the custom normal value.

This is intentionally a very basic implementation of custom normals.
In particular, the storage is not rotation invariant. So the normals
are expected to be set procedurally at the end of the modifier stack.
On the other hand, it is very easy to understand and explain.

#116066
-------
).
The
Viewer
node overlay can now be displayed as text values directly
  instead of colors (
b85011aee0
### Commit Summary: Geometry Nodes: initial display of attribute values as text in 3d viewport ¬∑ b85011aee0 - blender - Blender Projects
### Commit Details:
Previously, attribute values were only visualized as color overlay in the 3d viewport.
Now it's possible to optionally show the attribute values as text. This can be enabled
in the `Viewer Node` overlay settings in the 3d view.

This is just the first initial version. More work towards making it look better
will be done next.

#115664
-------
).
The
Blackbody
shader node is supported in geometry nodes
  (
3f485c8bf3
### Commit Summary: Geometry Nodes: add support for blackbody shader node ¬∑ 3f485c8bf3 - blender - Blender Projects
### Commit Details:
This adds the existing Blackbody shader node to geometry nodes, with the
same functionality.

#114768
-------
).
Modifier
¬∂
Node panels are now displayed in the modifier interface,
  making it much simpler to organize
  (
ad7a5abb2d
### Commit Summary: Geometry Nodes: support panels in geometry nodes modifier ¬∑ ad7a5abb2d - blender - Blender Projects
### Commit Details:
This builds on top of
f824476bd5
to show
panels in the geometry nodes modifier. It also changes the two existing panels
to use the new layout panels.

The open-close state of the panels is stored in the modifier itself. It contains a
mapping from panel id to the corresponding state flag.

#116472
-------
).
The panels in the geometry nodes modifier have been reorganized
  (
9df4ffc0c2
### Commit Summary: Geometry Nodes: reorganize panels in modifier ¬∑ 9df4ffc0c2 - blender - Blender Projects
### Commit Details:
The goal is to simplify the interface of the geometry nodes modifier while also
making it more scalable. This allows creating better looking modifiers which
feel more built-in. No functionality is removed by this patch.

The following changes are done:
* The `Output Attributes` panel is hidden when there are no output attributes.
* The `Internal Dependencies` panel is replaced by a new `Manage` panel that
  contains all the stuff that is common to all geometry nodes modifiers. It
  contains new `Bake` and `Named Attributes` panels for now.

Potential next steps:
* Merge `Output Attributes` panel with the rest of the input list.
* Support hiding the `Manage` panel under some circumstances.

#117170
-------
):
The
Output Attributes
panel is hidden when it is empty.
A new
Manage
panel contains a new
Bake
and
Named Attributes
panel.
Performance
¬∂
The
Extrude Mesh
can be over 6 times faster for large meshes with
  many vertex groups (
6aaa74cda9
### Commit Summary: Geometry Nodes: Improve extrude node vertex group performance ¬∑ 6aaa74cda9 - blender - Blender Projects
### Commit Details:
Add separate functions that deal with the vertex domain and copy vertex
groups without using the attribute API which has a large overhead when
abstracting the access of many vertex groups.

In a 1m vertex mesh with 20 vertex groups, I observed an improvement
in the node's runtime from 399 ms to 64 ms.

Also
resolves
#117553
. That was an error when adding weight data to a
mesh without any weight data would invalidate custom data layers. That
is solved more simply now by just doing nothing in that case.
-------
).
The
Shortest Edge Paths
node can be at least 60% faster
  (
c106066900
### Commit Summary: Geometry Nodes: Improve Shortest Edge Paths node performance ¬∑ c106066900 - blender - Blender Projects
### Commit Details:
Speedup of node Shortest Edge Paths node by creating an array for
other_edge_vert's and computing them in parallel separate loop.
This also provides better CPU cache by avoiding reading edges in main
loop to find other vertex (which happen multiple time for each vertex).

For cuboid with `700`x`700`x`700` points and `0.066667%` random
selection of `Edge Vertex` this will change `1012.4 ms` -> `618.9 ms`
the in `shortest_paths` function.

Co-authored-by: Hans Goudey
#114707
-------
).
The
Face Group Boundaries
node can be over three times faster
  (
5429e006c8
### Commit Summary: Geometry Nodes: Face Group Boundaries node speedup ¬∑ 5429e006c8 - blender - Blender Projects
### Commit Details:
The multithreaded algorithm works by atomically assigning each face's
group ID to the surrounding edges. If the ID for the edge is different
than one set previously, the edge becomes a boundary.

Using the edge to face topology map was also tested, but it wasn't
faster, and given the large memory usage of the map, the increased
complexity of this algorithm was considered worthwhile.

Speed improvement for attached example file is listed in table:
| Cube resolution | Main | PR |
| -- | -- | -- |
| 20x20x20 | `71920 ns` | `97400 ns` |
| 100x100x100 | `1.27 ms` | `1.17 ms` |
| 500x500x500 | `79.37 ms` | `23.16 ms` |
| 1000x1000x1000 | `520.31 ms` | `142.21 ms` |

#115138
-------
).
The
Edges to Face Groups
node can be over seven times faster
  (
274b2dbe5e
### Commit Summary: Geometry Nodes: Parallel Edges to Face Groups ¬∑ 274b2dbe5e - blender - Blender Projects
### Commit Details:
This loop might be 7x faster (not whole node).
All other code is already parallel, not sure why this was disabled.
Potentially, this was missed after some cleanup.

#115246
-------
,
33442e0992
### Commit Summary: Geometry Nodes: Edges to Face Groups speedup ¬∑ 33442e0992 - blender - Blender Projects
### Commit Details:
Remove unnecessary N^2\n complexity. Disjoint set will join all
elements in list, even without fully-related joins. Usually cost is
small (10%~ for this specific function), but some certain files might
be 10000x slower. But that is very corner case.

#115245
-------
).
Auto Smooth
¬∂
The mesh "Auto Smooth" option has been replaced by a modifier node
  group asset
  (
89e3ba4e25
### Commit Summary: Mesh: Replace auto smooth with node group ¬∑ 89e3ba4e25 - blender - Blender Projects
### Commit Details:
Design task:
#93551
This PR replaces the auto smooth option with a geometry nodes modifier
that sets the sharp edge attribute. This solves a fair number of long-
standing problems related to auto smooth, simplifies the process of
normal computation, and allows Blender to automatically choose between
face, vertex, and face corner normals based on the sharp edge and face
attributes.

Versioning adds a geometry node group to objects with meshes that had
auto-smooth enabled. The modifier can be applied, which also improves
performance.

Auto smooth is now unnecessary to get a combination of sharp and smooth
edges. In general workflows are changed a bit. Separate procedural and
destructive workflows are available. Custom normals can be used
immediately without turning on the removed auto smooth option.

**Procedural**

The node group asset "Smooth by Angle" is the main way to set sharp
normals based on the edge angle. It can be accessed directly in the add
modifier menu. Of course the modifier can be reordered, muted, or
applied like any other, or changed internally like any geometry nodes
modifier.

**Destructive**
Often the sharp edges don't need to be dynamic. This can give better
performance since edge angles don't need to be recalculated. In edit
mode the two operators "Select Sharp Edges" and "Mark Sharp" can be
used. In other modes, the "Shade Smooth by Angle" controls the edge
sharpness directly.

### Breaking API Changes
- `use_auto_smooth` is removed. Face corner normals are now used
  automatically   if there are mixed smooth vs. not smooth tags. Meshes
  now always use custom normals if they exist.
- In Cycles, the lack of the separate auto smooth state makes normals look
  triangulated when all faces are shaded smooth.
- `auto_smooth_angle` is removed. Replaced by a modifier (or operator)
  controlling the sharp edge attribute. This means the mesh itself
  (without an object) doesn't know anything about automatically smoothing
  by angle anymore.
- `create_normals_split`, `calc_normals_split`, and `free_normals_split`
  are removed, and are replaced by the simpler `Mesh.corner_normals`
  collection property. Since it gives access to the normals cache, it
  is automatically updated when relevant data changes.

Addons are updated here:
blender/blender-addons#104609
### Tests
- `geo_node_curves_test_deform_curves_on_surface` has slightly different
   results because face corner normals are used instead of interpolated
   vertex normals.
- `bf_wavefront_obj_tests` has different export results for one file
  which mixed sharp and smooth faces without turning on auto smooth.
- `cycles_mesh_cpu` has one object which is completely flat shaded.
  Previously every edge was split before rendering, now it looks triangulated.

#108014
-------
).
This means geometry nodes now has the ability to set edge sharpness
  and create split normals without the need for an "original" mesh
  with the auto smooth option.
The behavior of sharp handles in the *Curve to Mesh* node is
  also controllable, and possible to create from scratch.
Blender automatically chooses whether to calculate vertex, face, or
  face corner normals given the presence of custom normals and the mix
  of sharp/smooth edges and faces.
Face corner "split" normals are calculated when there is a mix of
  sharp and smooth elements.
For more information on the impact to modeling, see the
Modeling
section.
For more information on the Python API changes, see the
Python
  API
section.
A node group asset to replace the behavior of the Auto Smooth option

'''''


6. Blender 4.1: Import & Export¬∂

Blender 4.1: Import & Export
¬∂
New File Handler API
¬∂
File Handlers allow developers to extend traditional file "import" operators
with drag-and-drop behavior throughout the Blender UI.
(
7c5fa8bf6c
### Commit Summary: IO: Add initial support for File Handlers registration ¬∑ 7c5fa8bf6c - blender - Blender Projects
### Commit Details:
Adds initial support for File Handler registration with the python API
for design task
#68935
. File Handlers will allow developers to associate
additional UI behavior and capability to operators traditionally used
only within the file browser.

The initial commit should have no user visible changes, but will serve
as the foundation for providing file drag & drop capabilities to
operators that can manage files (
#111242
).

See the PR for an example of python usage.
See design task
#68935
for remaining work to be explored in the future.

#112466
-------
,
1254fee589
### Commit Summary: IO: Add support for Drag and Drop to FileHandlers ¬∑ 1254fee589 - blender - Blender Projects
### Commit Details:
Added support to Drag and Drop to file handlers, part of
#111242
.

If file handlers are registered with an import operator they can now be
invoked with drag and drop path data.

Import operators must either declare a `filepath` StringProperty or both
a `directory` StringProperty and a `files` CollectionProperty depending
on if they support single or multiple files respectively.

Multiple FileHandlers could be valid for handling a dropped path. When
this happens a menu is shown so the user can choose which exact handler
to use for the file.

#116047
-------
)
Initial use of file handlers for drag-and-drop support has been enabled for the following
file formats within the 3D Viewport and Outliner areas:
Alembic, Collada, Grease Pencil SVG, OBJ, OpenUSD, PLY, and STL
(
d4bc3bd08d
### Commit Summary: IO: Add file handlers to c++ import operators ¬∑ d4bc3bd08d - blender - Blender Projects
### Commit Details:
Adds file handlers for the C++ import operators.
This will allow these operators to be invoked with drag-and-drop
filepath data in the 3D Viewport or the Outliner.

When the operators are called with drag-and-drop data a dialog popup
will be used instead of invoking the file select window.

Previously OPTYPE_REGISTER tag had no effect, now since these operators
can run as popup dialogs this flag is removed to prevent heavy io
operations in the redo panel.

Also includes drawing functions for ply and stl and a missing
event notifications to collada import.

Important: Presets can override file path properties, so if a preset is
used, file paths provided by drag and drop will be lost. This will be
addressed in follow up changes.

#116873
-------
)
Support for additional formats, notably those that are implemented as Python addons,
will be added in the future.
Python API examples are available in the
documentation
.
USD
¬∂
New capabilities
Export armatures and shape keys (
c6d61e8586
### Commit Summary: USD: Support armature and shape key export ¬∑ c6d61e8586 - blender - Blender Projects
### Commit Details:
New functionality to export armatures and shape keys as USD
skeletons and blend shapes.

Added "Armature", "Only Deform Bones" and "Shape Key" USD export options.

Added USDArmatureWriter class.

Extended USDMeshWriter to write skinned meshes for binding
with skeletons and 'neutral' meshes with blend shape targets.
Specifically, when exporting an armature, a skinned mesh is written
in its pre-modified rest position.  When exporting to blend shapes,
a mesh with shape keys is saved with its vertices in the shape key
basis shape position.

Added USDHierarchyIterator::process_usd_skel() function to
finish processing skeleton and blend shape export after the
writer instances completed writing.  This is necessary because
some of the export operations require processing multiple prims
at once.

Extended USDTransformWriter::do_write() to write transforms
sparsely, to avoid saving redundant transform values when exporting
armatures.

Added a create_skel_roots() function, called on the stage at the
end of the export.  This function attempts to ensure that skinned
prims and skeletons are encapsulated under SkelRoot primitives,
which is required in USD for correct skinning behavior.

When exporting blend shape animations for multiple meshes bound
to a single skeleton, we need to merge the blend shape time samples
of the different meshes into a single animation primitive at the end
of the export.  This requires some tricky book keeping, where the weight
time samples for a given mesh are initially saved by the mesh writer to a
temporary attribute on the mesh and are later copied to the animation
primitive as one of the final steps.

When writing blend shapes and skinned meshes, the pre-modified mesh
is exported.  This is to ensure that the number of blend shape offsets
matches the number of points, and so that the skinned mesh is saved in
its rest position.

Because the pre-modified mesh must be exported, modifiers in addition
to Armature modifiers will not be applied.  This still allows the round trip
UsdSkel -> Blender -> UsdSkel, but some additional setup might be
required to export to UsdSkel when there are multiple modifiers (for
example, applying mirroring modifiers that precede the armature
modifier).

Exporting bendy bones or absolute shape keys isn't currently
supported.

Co-authored-by: Charles Wardlaw
#111931
-------
).
Scene graph instancing import support (
ea89e11e01
### Commit Summary: USD: import scenegraph instances. ¬∑ ea89e11e01 - blender - Blender Projects
### Commit Details:
Added support for importing USD instanceable primitives into Blender
as collection instances.

Added a new USDInstanceReader class for importing USD
instances as Blender objects that instance collections containing
prototype data.

Extended the USDStageReader to read USD prototype prims into
collections that are instanced on the objects created by the instance
readers.

Removed the "Import Instance Proxies" import option.

Importing instances is enabled with a new "Scene Instancing" import
option, which is true by default.  If this option is off, instances will be
imported as copies (which is the functionality previously enabled by
the "Import Instance Proxies" option).

Removed calls to UsdSkelBindingAPI::Apply() in the skeleton and
blend shape import code, as these calls were unnecessary and were
generating errors when importing instance prototypes with UsdSkel
data.

Nested instancing and animated prototypes are supported.

#115076
-------
).
Point instancing import support (
fcd10ee33a
### Commit Summary: USD: PointInstancer import support ¬∑ fcd10ee33a - blender - Blender Projects
### Commit Details:
Added support for static point instancing import.

Added a new USDPointInstancerReader class to import UsdGeomPointInstancer
primitives as Point Clouds with geometry node modifiers that use
Instance on Points geometry nodes to instance collections containing
prototype geometry.

Added logic to the USDStageReader class to traverse the USD stage to
create readers for point instancer prototypes.

Extended USDStageReader::collect_readers() to take arguments to include
undefined prims and to exclude a set of specified prims when traversing
the stage.  Allowing traversing undefined prims is necessary because
prototype prims may be specified as "overs" in the USD stage.

Added a USDPrimReader::is_in_instancer_proto_ boolean flag which
identifies readers of prims that are in point instancer prototypes.
The flag simplifies management of collections and is used to
determine whether global transforms should be applied to root objects.

Limitation: point cloud animation is not yet supported.

This partially addresses
#96747
.

Co-authored-by: Michael Kowalski
#113107
-------
).
Optionally author subdivision schema on export (
5edda6cbcc
### Commit Summary: USD: optionally author subdivision schema on export ¬∑ 5edda6cbcc - blender - Blender Projects
### Commit Details:
USD: optionally author subdivision schema on export

This PR adds support for exporting USD assets which have the subdivision
schema applied. Current behavior prior to this PR is that the effects of
Subdivision Surface modifiers are always applied to their mesh prior to
export, such that it is not possible to recover the original base mesh.

In this PR we provide three options for the subdiv schema type:

Ignore - Export base mesh without subdivision with USD Scheme = None
Tessellate - Export subdivided mesh with USD Scheme = None
Best Match (default) - Export base mesh with USD Scheme = Catmull-Clark

"Best Match" here means that Blender will set a subdiv scheme type in
the exported USD asset when it is possible to closely match the
subdivision surface type that was authored in Blender. At this time
Blender provides two subdivision types: Catmull-Clark and Simple.

Because Simple does not have a corresponding subdivision type in USD, we
do not attempt to convert or represent it, and instead the Simple subdiv
modifier will be evaluated and applied to the mesh during export.

Whenever a Catmull-Clark Subdivision Surface modifier is applied to an
object, and is the last modifier in the stack, it is possible to set the
subdiv scheme to Catmull-Clark for the respective prim in the exported
USD file.

Authored by Apple: Matt McLin

Co-authored-by: Matt McLin
Co-authored-by: Brecht Van Lommel
#113267
-------
).
Import can now be extended with Python scripts through hooks.
  See the USDHook API
documentation
for details and example code (
ecbf3385c5
### Commit Summary: USD: basic support for on_import USD hooks ¬∑ ecbf3385c5 - blender - Blender Projects
### Commit Details:
Added support for defining an on_import() function in
bpy.types.USDHook subclasses.  If on_import() is defined
on a given USD hook, it will be invoked in import_endjob().

The implementation closely follows the existing design of
export hooks.  USDHook.on_import() takes as an argument
an instance of an internally defined USDSceneImportContext
class which provides an accessor to the USD stage.

Also updated the USDHook documentation with an example
on_import() callback implementation.

#117822
-------
).
Notable improvements
Export to a single root prim by default (
b262655d39
### Commit Summary: USD: export to a single root prim by default ¬∑ b262655d39 - blender - Blender Projects
### Commit Details:
This PR adds the following changes:

A single root is always set as default. After talking to Wave and
Spiff, we settled on root being the best default. Users who don't
want a single root prim inserted, can choose to clear the field
The root prim no longer requires the user to prefix the field with /.
It will implicitly insert that for them.

On export, the root_prim hierarchy is now defined all as Xform
instead of just the final prim in the path. Each prim also has
custom metadata added to show that it was generated by Blender.
This follows convention in other DCCs as well.

On import, the code now finds the hierarchy of generated prims
using that metadata. It then skips importing them. This means that
you can roundtrip hierarchies even with an inserted root.

Co-authored-by: Dhruv Govil
#113187
-------
).
Author the extents property for lights on export (
e6ff1348cb
### Commit Summary: Fix: USD Export: Calculate extents property for lights ¬∑ e6ff1348cb - blender - Blender Projects
### Commit Details:
Lights without calculated extents are not considered correct USD.
This is now possible with the APIs provided by recent USD versions.

#113910
-------
).
Add scale and bias processing for UsdUVTexture (
f355b20262
### Commit Summary: Fix #106326: Add scale-bias processing for UsdUVTexture ¬∑ f355b20262 - blender - Blender Projects
### Commit Details:
This adds the processing required to import and export, simple, material
graphs utilizing the UsdUVTexture Scale and Bias inputs.

Since Blender does not have equivalent inputs on its Image node, a
Multiply-Add node is used instead. This matches the calculation as per
the UsdPreviewSurface spec[1]

A complicating factor here is when these two inputs are used for normal
map textures. The Scale and Bias inputs are authored in such a way to
take the [0, 1] image data and expand into the [-1, 1] tangent space
range as per the spec. However, the Blender Normal Map node expects to
do this transformation itself. The processing in this patch needs to
account for this. For the case of normal maps it will:
- Apply the Scale-Bias calculation directly as authored
- Apply an additional transform to move from [-1, 1] back into [0, 1]
- Feeds this into the Normal Map node

This processing extends to Export as well. During material graph
traversal we need to "skip" the middle adjustment transform and only
export the "real" Scale-Bias data. Traversing the graph like this can be
error prone but is probably the best we can do without having a native
Scale-Bias concept on Blender's Image node.

[1]
https://openusd.org/release/spec_usdpreviewsurface.html#texture-reader
#115224
-------
).
Add channel processing for UsdUVTexture (
228ee8f1c3
### Commit Summary: Fix #96458: Add channel processing for UsdUVTexture ¬∑ 228ee8f1c3 - blender - Blender Projects
### Commit Details:
This adds the processing required to import and export simple material graphs utilizing the UsdUVTexture outputs channels.

If only r, g or b are specified as output, we hook up a `Separate Color` node and connect the appropriate channel from there.
(if a is specified as output, the Alpha output of an image texture node was used already)

On the export side, we traverse from the socket to the image texture node, and if a `Separate Color` on the way, we are using the channel from there to put on the output.
https://openusd.org/release/spec_usdpreviewsurface.html#texture-reader
#117901
-------
).
Alembic
¬∂
Velocities on Points are now read (
472cf44166
### Commit Summary: Alembic: read velocities on Points ¬∑ 472cf44166 - blender - Blender Projects
### Commit Details:
This is reusing the generic system from
128eb6cbe9
which at that time
was only done for the mesh reader and is now done for the point reader
as well.

This allows for rendering with proper motion blur for alembic points
(which of course are still imported as meshes - were just lacking the
velocity attribute) when directly rendering as points in Cycles.

Came up in
#109185
(where instancing is used - which is still not
supported, this patch is just for direct point rendering in Cycles).

Unsure about the status of
https://archive.blender.org/developer/D11591
but until that lands, having velocities for points sounds useful enough
to support this now.
Fixes
#95945
#116749
-------
).
Render resolution is now written to cameras (
5412bd48a9
### Commit Summary: Alembic: export render resolution on cameras ¬∑ 5412bd48a9 - blender - Blender Projects
### Commit Details:
Blender's cameras don't have specific resolution configured to them,
instead they use the scene's resolution.
This is a problem when exporting a camera using Alembic. Other software
(like Houdini) expects the resolution parameters on the camera itself.

So now store the scene's resolution on each camera that is exported.
Since this is not part of the concept of a camera in alembic itself,
export these as `userProperties` in a way other software can read this.
Fixes
#116375
#116782
-------
).
STL
¬∂
New STL (.stl) exporter
  (
17c793e43c
### Commit Summary: IO: C++ STL exporter ¬∑ 17c793e43c - blender - Blender Projects
### Commit Details:
There was a C++ STL importer since Blender 3.3, but no corresponding C++ STL exporter. This PR is adding said exporter: taking
#105598
and finishing it (agreed with original author).

Exporting Suzanne with 6 level subdivision (4 million triangles), on Apple M1 Max:
- Binary: python exporter 7.8 sec -> C++ exporter 0.9 sec.
- Ascii: python exporter 13.1 sec -> C++ exporter 4.5 sec.

Co-authored-by: Iyad Ahmed
#114862
-------
).
  The new exporter is written in C++ and is 3x-10x faster than the
  Python exporter.
Python STL exporter/importer add-on has been marked as legacy. Users of
bpy.ops.export_mesh.stl
/
bpy.ops.import_mesh.stl
are advised to switch to
new STL exporter/importer functions
bpy.ops.wm.stl_export
/
bpy.ops.wm.stl_import
.
FBX
¬∂
Normals are now exported as vertex normals when the
Mesh.normals_domain
property is
'POINT'
.
  (
3d823efc57
)
Normals are now exported using the
IndexToDirect
FBX reference
  mode.
  (
791b042c3a
)
Older versions of the FBX I/O add-on do not support importing vertex
  normals with this reference mode, but will still import FBX I/O
  exported meshes with the correct normals because the vertex normals
  that cannot be imported will match the normals of the imported mesh.
  Custom normals won't be set in this case.
Stanford PLY
¬∂
PLY importer and exporter now supports custom vertex attributes
  (
0eb6aef3b0
### Commit Summary: PLY: import/export custom vertex attributes (#108948) ¬∑ 0eb6aef3b0 - blender - Blender Projects
### Commit Details:
Implements
#108948
- support for custom point domain attributes for PLY
import and export. Notes:

- Custom attributes are always represented as scalar floats. PLY itself
  has some data types that blender can't fully represent, e.g. double or
  uint32, or some that fit into a float just fine but blender does not have
  them as separate types (e.g. int16).
- When importing, any PLY vertex attribute that is not one of "standard"
  names (position, normal, etc.) gets turned into a custom attribute.
- For exporting, more complex custom attributes (e.g. 2D/3D floats,
  quaternions, colors) get turned into several PLY attributes, with "_x"
  like suffix.

Custom attribute import/export is on by default in the UI.

#114320
Reviewed By: Hans Goudey
-------
).
OBJ
¬∂
Exporting completly flat or smooth shaded meshes can be up 20-40% faster
  (
94ca3aea83
### Commit Summary: OBJ: Use mesh normals domain properly for normals storage ¬∑ 94ca3aea83 - blender - Blender Projects
### Commit Details:
- Only calculate the necessary normals based on smooth/flat/mixed shading
- Use cached face normals instead of computing them
- Use a `VectorSet` for deduplication instead of a `Map`
- Deduplicate vertex normals and store indices in separate loops
- Avoid unnecessary duplication of face normal indices
- Inline simple function for slicing index span

Export time (ms) of 1.8m vertex mesh:
| Normals Domain  | Before | After |
| --------------- | ------ | ----- |
| Face (flat)     | 559    | 469   |
| Vertex (smooth) | 659    | 466   |
| Corner (mixed)  | 656    | 640   |

The change of using normals from different domains and using a
VectorSet for de-duplication change the order of normals in the OBJ
files. Other than that, the results should be unchanged.
Fixes
#117510
#117522
-------
).
3DS
¬∂
Export auto smooth angle from ¬¥Smooth by Angle ¬¥modifier.
  (
9a9142f160
)
glTF 2.0
¬∂
Find the changelog in the
Add-ons
section.

'''''


7. Blender 4.1: Modeling¬∂

Blender 4.1: Modeling
¬∂
Meshes
¬∂
Auto Smooth
¬∂
The "Auto Smooth" option has been replaced by a modifier node group asset
(
89e3ba4e25
### Commit Summary: Mesh: Replace auto smooth with node group ¬∑ 89e3ba4e25 - blender - Blender Projects
### Commit Details:
Design task:
#93551
This PR replaces the auto smooth option with a geometry nodes modifier
that sets the sharp edge attribute. This solves a fair number of long-
standing problems related to auto smooth, simplifies the process of
normal computation, and allows Blender to automatically choose between
face, vertex, and face corner normals based on the sharp edge and face
attributes.

Versioning adds a geometry node group to objects with meshes that had
auto-smooth enabled. The modifier can be applied, which also improves
performance.

Auto smooth is now unnecessary to get a combination of sharp and smooth
edges. In general workflows are changed a bit. Separate procedural and
destructive workflows are available. Custom normals can be used
immediately without turning on the removed auto smooth option.

**Procedural**

The node group asset "Smooth by Angle" is the main way to set sharp
normals based on the edge angle. It can be accessed directly in the add
modifier menu. Of course the modifier can be reordered, muted, or
applied like any other, or changed internally like any geometry nodes
modifier.

**Destructive**
Often the sharp edges don't need to be dynamic. This can give better
performance since edge angles don't need to be recalculated. In edit
mode the two operators "Select Sharp Edges" and "Mark Sharp" can be
used. In other modes, the "Shade Smooth by Angle" controls the edge
sharpness directly.

### Breaking API Changes
- `use_auto_smooth` is removed. Face corner normals are now used
  automatically   if there are mixed smooth vs. not smooth tags. Meshes
  now always use custom normals if they exist.
- In Cycles, the lack of the separate auto smooth state makes normals look
  triangulated when all faces are shaded smooth.
- `auto_smooth_angle` is removed. Replaced by a modifier (or operator)
  controlling the sharp edge attribute. This means the mesh itself
  (without an object) doesn't know anything about automatically smoothing
  by angle anymore.
- `create_normals_split`, `calc_normals_split`, and `free_normals_split`
  are removed, and are replaced by the simpler `Mesh.corner_normals`
  collection property. Since it gives access to the normals cache, it
  is automatically updated when relevant data changes.

Addons are updated here:
blender/blender-addons#104609
### Tests
- `geo_node_curves_test_deform_curves_on_surface` has slightly different
   results because face corner normals are used instead of interpolated
   vertex normals.
- `bf_wavefront_obj_tests` has different export results for one file
  which mixed sharp and smooth faces without turning on auto smooth.
- `cycles_mesh_cpu` has one object which is completely flat shaded.
  Previously every edge was split before rendering, now it looks triangulated.

#108014
-------
).
The base state of meshes is now the same as having "Auto Smooth" on
  with an angle of 180 degrees in older versions:
Face corner "split" normals are calculated when there is a mix of
  sharp and smooth elements.
Custom normals are used if available.
The modifier node group asset sets sharpness by the angle between
  faces.
Blender automatically chooses whether to calculate vertex, face, or
  face corner normals given the presence of custom normals and the mix
  of sharp/smooth edges and faces.
In edit mode, the new
Set Sharpness by Angle
operator can be used to
  set sharpness, or "Shade Smooth by Angle" in other modes
  (
78963b466b
### Commit Summary: Mesh: Add "Set Sharpness by Angle" operator ¬∑ 78963b466b - blender - Blender Projects
### Commit Details:
This simple  operator set the edge sharpness attribute on edges,
either extending the existing values or replacing them completely.
It's meant to make it more convenient to manually control the
sharpness now that there can be more reason to do that after
auto smooth became a modifier.

#117918
-------
).
For more information on the procedural smoothing modifier, see the
Nodes & Physics
section.
For more information on the Python API changes, see the
Python API
section.
Other
¬∂
A render "simplify" setting adds the ability to turn off calculation
  of face corner and custom normals in the viewport
  (
912c4c60d8
### Commit Summary: Mesh: Add viewport normals simplify option ¬∑ 912c4c60d8 - blender - Blender Projects
### Commit Details:
Before
#108014
, toggling "Auto Smooth" was an easy way to disable
evaluation of custom normals and face corner normals for faster
viewport playback performance. Now that corner normals are calculated
automatically as necessary, it's helpful to still have a way to disable
expensive normal computation for faster playback.

This commit adds a "Normals" scene simplify setting. To avoid a bunch
of complexity, it just influences which normals are requested from the
object by viewport rendering. In my tests, skipping calculating at
least doubled viewport FPS in a few test files with a large mesh with
custom normals. This works well because normals are cached and lazily
calculated.

#113975
-------
).
Shape Keys can now be locked to protect them from accidental edits via
  sculpting or edit mode transformation tools and operators.
  (
b350d7a4c3
### Commit Summary: Shape Keys: support locking to protect from accidental editing. ¬∑ b350d7a4c3 - blender - Blender Projects
### Commit Details:
It is very common for graphical editors with layers to support
locking individual layers to protect them from accidental edits due
to misclicks. Blender itself already supports locking vertex groups.
This adds lock toggles for shape keys, with lock/unlock all operators.

The flags are checked by sculpt brushes, edit mode transform tools,
and Smooth, Propagate and Blend From Shape operators. This selection
aims to cover operations that only deform the mesh, where the shape
key selection matters.

Topology changing operations always apply to all keys, and thus
incorrect shape key selection is less impactful. Excluding them
from the new feature greatly reduces the patch size.

#104463
-------
,
Manual
### Commit Summary: Shape Keys Panel - Blender 4.1 Manual
### Commit Details:
Shape Keys Panel
#
Reference
Editor
:
Properties
Mode
:
All modes
Panel
:
Object Data ‚Ä£ Shape Keys
Shape Keys panel.
#
The Shape Keys panel is used for authoring shape keys.
Active Shape Key Index
A
List View
.
Value/Frame (number)
In Relative mode: Value is the current influence of the shape key used for blending between
the shape (value=1.0) and its reference key (value=0.0). The reference key is usually the Basis shape.
The weight of the blend can be extrapolated above 1.0 and below 0.0.
In Absolute mode: Value is the
Evaluation Time
at which the shape will have maximum influence.
Mute (check mark)
If unchecked, the shape key will not be taken into consideration when
mixing the shape key stack into the result visible in the 3D Viewport.
Lock Shape (lock icon)
Shape keys can be locked to protect them from accidental modification due to inadvertently
selecting the wrong key for editing in the list. Most common sculpt and edit mode operators
and tools that move vertices abort with an error if the active shape key is locked.
Note
Operators that always modify all shape keys in exactly the same way, like
Apply Object Transforms
, don‚Äôt check shape key locks.
Neither currently do most edit mode operators that modify topology, because the topology is
expected to usually be finalized before shape keys are created.
Shape Key Specials
New Shape from Mix
Add a new shape key with the current deformed shape of the object.
This differs from the
+
button of the list, as that one always copies
the Basis shape independently of the current mix.
Mirror Shape Key
If your mesh is symmetrical, in
Object Mode
, you can mirror the shape keys on the X axis.
This will not work unless the mesh vertices are perfectly symmetrical.
Use the
Mesh ‚Ä£ Symmetrize
tool in
Edit Mode
.
Mirror Shape Key (Topology)
Same as
Mirror Shape Key
though it detects the mirrored vertices based on the topology of the mesh.
The mesh vertices do not have to be perfectly symmetrical for this action to work.
Join as Shapes (Transfer Mix)
Transfer the current resulting shape from a different object.
Select the object to copy, then the object to copy into.
Use this action and a new shape key will be added to the active object
with the current mix of the first object.
Transfer Shape Key
Transfer the active shape key from a different object
regardless of its current influence.
Select the object to copy, then the object to copy into.
Use this action and a new shape key will be added to the active object
with the active shape of the first object.
Delete All Shape Keys
Removes all Shape Keys and any effect that they had on the mesh.
Apply All Shape Keys
Saves the current visible shape to the mesh data and deletes all Shape Keys.
Relative
Set the shape keys to
Relative
or
Absolute
.
See
Relative or Absolute Shape Keys
.
Shape Key Lock (pin icon)
Show the active shape in the 3D Viewport without blending.
Shape Key Lock
gets automatically enabled while the object is in
Edit Mode
.
Shape Key Edit Mode (edit mode icon)
If enabled, when entering
Edit Mode
the active shape key will
not
take maximum influence as is default.
Instead, the current blend of shape keys will be visible and can be edited from that state.
Add Rest Position
Creates an
Attribute
in the vertex domain called
rest_position
which is a copy of the
position
attribute before shape keys and modifiers are evaluated.
Only mesh objects support this option.
Relative Shape Keys
#
Relative Shape Keys options.
#
See
Relative or Absolute Shape Keys
.
With relative shape keys, the value shown for each shape in the list represents
the current weight or influence of that shape in the current
Mix
.
Clear Shape Keys
X
Set all influence values, or weights, to zero.
Useful to quickly guarantee that the result shown in the 3D Viewport is not affected by shapes.
Value
The weight of the blend between the shape key and its reference key (usually the Basis shape).
A value of 0.0 denotes 100% influence of the reference key and 1.0 of the shape key.
Range
Minimum and maximum range for the influence value of the active shape key.
Blender can extrapolate results when the
Value
goes lower than 0.0 or above 1.0.
Vertex Group
Limit the active shape key deformation to a vertex group.
Useful to break down a complex shape into components by assigning temporary vertex groups
to the complex shape and copying the result into new simpler shapes.
Relative To
Select the shape key to deform from. This is called the
Reference Key
for that shape.
Note
Rather than storing offsets directly, internally relative keys are stored as snapshots of the mesh shape.
The relative deformation offsets are computed by subtracting
Reference Key
from that snapshot.
Therefore, replacing the
Reference Key
has the effect of subtracting the difference between the new
and old reference from the relative deformation of the current key.
Absolute Shape Keys
#
Absolute Shape Keys options.
#
See
Relative or Absolute Shape Keys
.
With absolute shape keys, the value shown for each shape in the list represents
the
Evaluation Time
at which that shape key will be active.
Re-Time Shape Keys (clock icon)
Absolute shape keys are timed, by order in the list, at a constant interval.
This button resets the timing for the keys. Useful if keys were removed or re-ordered.
Interpolation
Controls the interpolation between shape keys.
Linear, Cardinal, Catmull-Rom, B-Spline
Different types of interpolation.
#
The red line represents interpolated values between keys (black dots).
Evaluation Time
Controls the shape key influence. Scrub to see the effect of the current configuration.
Typically, this property is keyed for animation or rigged with a driver.
-------
)
Face corner normals are cached and are recalculated in fewer cases
  (
62dbef895b
### Commit Summary: Mesh: Add missing sharing of cached face corner normals ¬∑ 62dbef895b - blender - Blender Projects
### Commit Details:
Sharing of the normals cache between copied meshes was missing from
89e3ba4e25
, which under-represented the benefits of the
change. In a simple file where geometry nodes causes a re-evaluation
without changing the normals, this increased FPS from 2.6 to 14.
-------
).
The creation of mesh topology maps used in geometry nodes and normals calculation
  is parallelized and elsewhere and can be over 5 times faster
  (
bb80716244
### Commit Summary: Mesh: Parallelize remaining topology maps ¬∑ bb80716244 - blender - Blender Projects
### Commit Details:
Similar to [0], but also including the further optimizations from [1],
parallelize the vertex to edge, vertex to face, and edge to face
topology map index creation (the first part of the maps was already
parallelized). Vertex to face index creation went from 9.8 ms to 1.7 ms
on average, for a 1 million vertex grid. That's nice, since this map
is used for vertex normals after [2].

[0]:
226359ec48
[1]:
98e33adac2
[2]:
5052e0d407
-------
).
Curves
¬∂
The new curves type supports new operators.
The "Draw" tool (
feae0b4173
### Commit Summary: Curves: Support for edit mode draw tool ¬∑ feae0b4173 - blender - Blender Projects
### Commit Details:
Adds new curves support to "Draw Curve" operator. This is a direct copy
and replace of the old code to the new editors directly, with a change to
create the new data structure instead of the old one. There is no attempt
at code deduplication, since that would complicate removing the old
curve type when it comes time.

To replace the "2D curve" option a new operator property is added
for projecting to the Z=0 plane.

#115864
-------
).
The draw tool has an option to create NURBS curves directly
  (
70fe812ef1
### Commit Summary: Curves: Add "As NURBS" option to draw tool ¬∑ 70fe812ef1 - blender - Blender Projects
### Commit Details:
Add an option to output curves as NURBS instead of Bezier. The same
fitting algorithms are used. The only difference is that the drawing
result is a NURBS curve with Bezier knot mode, instead of a native
Blender Bezier curve.

#116696
-------
)
The "Extrude" operator (
0d964f91a2
### Commit Summary: Curves: Add extrude operator ¬∑ 0d964f91a2 - blender - Blender Projects
### Commit Details:
Adds extrude operator to new curves. Press key E in edit mode to invoke.
It works correctly on Bezier curves also, but result is weird as there is no
way to control Bezier handles interactively. Currently operator works the
same way as in old curves.

Algorithm idea is same as in
https://archive.blender.org/developer/D15524
#116354
-------
).
The "Duplicate" operator (
9af176bfe6
### Commit Summary: Curves: Add edit mode duplicate operator ¬∑ 9af176bfe6 - blender - Blender Projects
### Commit Details:
Reuse the grease pencil implementation added in:
-
fb275bc040
- 5799a26568819ce27e8c12df96b7ffba84cc00f9
-------
).
Operators to control tilt (
0e8c874166
### Commit Summary: Curves: Add edit mode tilt control ¬∑ 0e8c874166 - blender - Blender Projects
### Commit Details:
Adds support for the tilt transform operator and a "Clear Tilt"
operator to mirror the functionality from the legacy curve type.
-------
).

'''''


8. Blender 4.1: Python API¬∂

Blender 4.1: Python API
¬∂
Python 3.11
¬∂
Python has been upgraded to
version 3.11
,
matching the VFX platform 2024.
Enum ID Properties
¬∂
Support for enum items has been added to integer properties.
92cf9dd2f2
### Commit Summary: ID properties: Support enum values with items ¬∑ 92cf9dd2f2 - blender - Blender Projects
### Commit Details:
Add support for enum values in ID properties.

This is needed for the "Menu Switch" node implementation (
#113445
) which
relies on ID properties for the top-level modifier UI.

Enums items can optionally be added to the UI data of integer
properties. Each property stores a full set of the enum items to keep
things simple.

Enum items can be added to properties using the `id_properties_ui`
function in the python API. A detailed example can be found in the
`bl_pyapi_idprop.py` test.

There is currently no support yet for editing enum items through the UI.
This is because the "Edit Property" feature is implemented entirely
through a single operator (`WM_OT_properties_edit`) and its properties.
Buttons to add/remove/move items would be operators changing another
operator's properties. A refactor of the custom properties UI is likely
required to make this work.

#114362
-------
There is no support yet for editing enum items through the UI (see
commit message for technical reasons).
Enum items can be added to an integer property using the
id_properties_ui
python method. The
as_dict
method can be used to retrieve a list of
enum items of a property.
my_object["my_prop"] = 2
ui_data = my_object.id_properties_ui("my_prop")
ui_data.update(items=[
    ("TOMATOES", "Tomatoes", "Solanum lycopersicum"),
    ("CUCUMBERS", "Cucumbers", "Cucumis sativus"),
    ("RADISHES", "Radishes", "Raphanus raphanistrum"),
])
print(ui_data.as_dict())
The existing conveniency wrapper function supports it as well:
from rna_prop_ui import rna_idprop_ui_create

rna_idprop_ui_create(my_object, "my_prop", default=2, items=[
    ("TOMATOES", "Tomatoes", "Solanum lycopersicum"),
    ("CUCUMBERS", "Cucumbers", "Cucumis sativus"),
    ("RADISHES", "Radishes", "Raphanus raphanistrum"),
])
Int properties with enum items are shown as a dropdown button in the UI.
Layout Panels
¬∂
Blender has new so called "layout panels".
These panels are defined inside of
draw
functions and don't require extra registration.
This significantly reduces the amount of code required to create collapsable sections in a panel.
(
f824476bd5
### Commit Summary: UI: add support for uiLayout based panels ¬∑ f824476bd5 - blender - Blender Projects
### Commit Details:
This adds support for so called "layout panels" which are panels that are created as part
of `uiLayout`. The goal is to make it easier to have expandable sections as part of a UI.

The initial use case for this are panels in the geometry nodes modifier. This patch provides
a better solution compared to what was attempted in
#108565
.

### Problems with Existing Approaches

Currently, there are two ways to create these expandable sections:
* One can define a new `Panel` type for each expandable section and use the `parent_id`
  to make this a subpanel of another panel. This has a few problems:
  * `uiLayout` drawing code is more scattered, because one can't just use a single function
    that creates the layout for an entire panel including its subpanels.
  * It does not work so well for dynamic amounts of panels (e.g. like what we need for
    the geometry nodes modifier to organize the inputs).
  * Typically, Blender uses a immediate-ui approach, but subpanels break that currently
    and need extra handling.
  * The order of panels is not very explicit.
  * One can't interleave subpanels and other ui elements, subpanels always come at the
    end of the parent panel.
* Custom solution using existing `uiLayout`. This is done in the material properties. It
  also has a few problems:
  * Custom solutions tend to work slightly different in different places. So the UI is less unified.
  * Can't drag open/close multiple panels.
  * The background color for subpanels does not change.

### Solution

A possible solution to all of these problems is to add support for panels to `uiLayout` directly:
```cpp
/* Add elements before subpanel. */
if (uiLayout *panel_layout = uiLayoutPanel(layout, ...)) {
  /* Add elements in subpanel, but only of the panel is open. */
}
/* Add elements after subpanel. */
```

Integrating subpanels with `uiLayout` has some benefits:
* Subpanels are treated like any other sub-layout and don't have unnecessary boilerplate.
* It becomes trivial to have a dynamic number of potentially nested subpanels.
* Resolves all mentioned problems of custom subpanel solutions.

### Open/Close State

The most tricky thing is to decide where to store the open/close state. Ideally, it should
be stored in the `region` because then the same layout panel can be opened and closed
in every region independently. Unfortunately, storing the state in the region is fairly
complex in some cases.

For example, for modifier subpanels the region would have to store an open/close state
for each panel in each modifier in each object. So a map with
`object pointer + modifier id + panel id` as key would be required. Obviously, this map
could become quite big. Also storing that many ID pointers in UI data is not great and
we don't even have stable modifier ids yet. There also isn't an obvious way for how to
clear unused elements from the map which could become necessary when it becomes big.

In practice, it's rare that the same modifier list is shown in two editors. So the benefit of
storing the open/close state in the region is negligible. Therefor, a much simpler solution
is possible: the open/close state can be stored in the modifier directly. This is actually
how it was implemented before already (see `ui_expand_flag`).

The implementation of layout panels in this patch is *agnostic* to how the open/close
state is stored exactly, as long as it can be referenced as a boolean rna property. This
allows us to store the state in the modifier directly but also allows us to store the state
in the region for other layout panels in the future. We could consider adding an API that
makes it easy to store the state in the region for cases where the key is simpler.
For example: `uiLayoutPanel(layout, TIP_("Mesh Settings"), PanelRegionKey("mesh_settings"))`.

### Python API (not included)

Adding a Python API is fairly straight forward. However, it is **not** included in this patch
so that we can mature the internal API a bit more if necessary, before addon developers
start to depend on it. It would probably work like so:

```python
if panel := layout.panel("Mesh Settings", ...):
    # Add layout elements in the panel if it's open.
```

#113584
-------
,
8896446f7e
### Commit Summary: Python: add Python API for layout panels ¬∑ 8896446f7e - blender - Blender Projects
### Commit Details:
This adds a Python API for layout panels that have been introduced in
#113584
.
Two new methods on `UILayout` are added:
* `.panel(idname, text="...", default_closed=False) -> Optional[UILayout]`
* `.panel_prop(owner, prop_name, text="...") -> Optional[UILayout]`

Both create a panel and return `None` if the panel is collapsed. The difference lies
in how the open-close-state is stored. The first method internally manages the
open-close-state based on the provided identifier. The second one allows for
providing a boolean property that stores whether the panel is open. This is useful
when creating a dynamic of panels and when it is difficult to create a unique idname.

For the `.panel(...)` method, a new internal map on `Panel` is created which keeps
track of all the panel states based on the idname. Currently, there is no mechanism
for freeing any elements once they have been added to the map. This is unlikely to
cause a problem anytime soon, but we might need some kind of garbage collection
in the future.

```python
import bpy
from bpy.props import BoolProperty

class LayoutDemoPanel(bpy.types.Panel):
    bl_label = "Layout Panel Demo"
    bl_idname = "SCENE_PT_layout_panel"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "scene"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.label(text="Before")

        if panel := layout.panel("my_panel_id", text="Hello World", default_closed=False):
            panel.label(text="Success")

        if panel := layout.panel_prop(scene, "show_demo_panel", text="My Panel"):
            panel.prop(scene, "frame_start")
            panel.prop(scene, "frame_end")

        layout.label(text="After")

bpy.utils.register_class(LayoutDemoPanel)
bpy.types.Scene.show_demo_panel = BoolProperty(default=False)
```

#116949
-------
,
ddd06eeb8f
### Commit Summary: UI: Add ability to configure the header row of layout panels ¬∑ ddd06eeb8f - blender - Blender Projects
### Commit Details:
There are many instances where customizing the header row is desired so
return both the header row layout and the main body layout.

For consistency and correctness, the arrow symbol and the is_open check
are always performed so callers only need to perform layout tasks.

The C++ side now receives a `PanelLayout` structure containing both:
```cpp
PanelLayout panel_layout = uiLayoutPanelWithHeader( ... );
uiItemL(panel_layout.header, ... );
if (panel_layout.body) {
    ...
}
```

And the Python side receives a tuple:
```python
header, body = layout.panel( ... )
header.label(...)
if body:
    ...
```

```python
import bpy
from bpy.props import BoolProperty

class LayoutDemoPanel(bpy.types.Panel):
    bl_label = "Layout Panel Demo"
    bl_idname = "SCENE_PT_layout_panel"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "scene"

    def draw(self, context):
        layout = self.layout
        scene = context.scene

        layout.label(text="Basic Panels")

        header, panel = layout.panel("my_panel_id", default_closed=True)
        header.label(text="Hello World")
        if panel:
            panel.label(text="Success")

        header, panel = layout.panel_prop(scene, "show_demo_panel")
        header.label(text="My Panel")
        if panel:
            panel.prop(scene, "frame_start")
            panel.prop(scene, "frame_end")

        layout.label(text="Customized headers")

        # Add a checkbox to the Panel header. text must be None for this panel
        header, panel = layout.panel("my_panel_id-2", default_closed=True)
        header.prop(scene, "use_checkmark", text="") # text must be empty for the checkbox
        header.label(text="Checkmark at beginning")
        if panel:
            panel.label(text="Success")

        header, panel = layout.panel("my_panel_id-3", default_closed=True)
        header.label(text="Buttons at the end")
        header.operator("mesh.primitive_cube_add", text="", icon='EXPORT')
        header.operator("mesh.primitive_cube_add", text="", icon='X')
        if panel:
            panel.label(text="Success")

        header, panel = layout.panel("my_panel_id-4", default_closed=True)
        header.prop(scene, "use_checkmark2", text="")
        header.label(text="Both")
        header.operator("mesh.primitive_cube_add", text="", icon='EXPORT')
        header.operator("mesh.primitive_cube_add", text="", icon='X')
        if panel:
            panel.label(text="Success")

bpy.utils.register_class(LayoutDemoPanel)
bpy.types.Scene.show_demo_panel = BoolProperty(default=False)
bpy.types.Scene.use_checkmark = BoolProperty(default=False)
bpy.types.Scene.use_checkmark2 = BoolProperty(default=False)
```

#117248
-------
)
import
bpy
from
bpy.props
import
BoolProperty
class
LayoutDemoPanel
(
bpy
.
types
.
Panel
):
bl_label
=
"Layout Panel Demo"
bl_idname
=
"SCENE_PT_layout_panel"
bl_space_type
=
'PROPERTIES'
bl_region_type
=
'WINDOW'
bl_context
=
"scene"
def
draw
(
self
,
context
):
layout
=
self
.
layout
scene
=
context
.
scene
layout
.
label
(
text
=
"Before"
)
header
,
panel
=
layout
.
panel
(
"my_panel_id"
,
default_closed
=
False
)
header
.
label
(
text
=
"Hello World"
)
if
panel
:
panel
.
label
(
text
=
"Success"
)
header
,
panel
=
layout
.
panel_prop
(
scene
,
"show_demo_panel"
)
header
.
label
(
text
=
"My Panel"
)
if
panel
:
panel
.
prop
(
scene
,
"frame_start"
)
panel
.
prop
(
scene
,
"frame_end"
)
layout
.
label
(
text
=
"After"
)
bpy
.
utils
.
register_class
(
LayoutDemoPanel
)
bpy
.
types
.
Scene
.
show_demo_panel
=
BoolProperty
(
default
=
False
)
Breaking Changes
¬∂
Foreach
¬∂
foreach_get
and
foreach_set
have been optimized for cases where internal
storage is 8, 16 or 64 bit. (
PR#115761
)
foreach_set
now performs more accurate bounds checks, and raises a
TypeError
in cases where the value was previously silently written
incorrectly.
Light Probes
¬∂
The Lightprobe type items have been renamed. It affects
bpy.types.LightProbe.type
,
bpy.types.BlendDataProbes.new()
and
bpy.ops.object.lightprobe_add()
.
CUBEMAP
->
SPHERE
PLANAR
->
PLANE
GRID
->
VOLUME
show_data
has been deprecated. Use
use_data_display
instead.
Each
LightProbe
now has its own
data_display_size
property.
Mesh
¬∂
Sculpt mask values are stored in a generic attribute
  (
f2bcd73bd2
### Commit Summary: Mesh: Move sculpt mask to a generic attribute ¬∑ f2bcd73bd2 - blender - Blender Projects
### Commit Details:
Store paint masks as generic float attributes, with the name
`".sculpt_mask"`. This is similar to
060a534141
, which made
the same change for face sets. The benefits are general
consistency, nicer code, and more support in newer areas
that deal with attributes like geometry nodes.

The RNA API is replaced with one created in Python. The new
API only presents a single layer as an attribute class, so it
should be simpler to use in general:
- Before: `object.data.vertex_paint_masks[0].data[0].value`
- After: `object.data.vertex_paint_mask.data[0].value`

#115119
-------
).
The name is ".sculpt_mask", with the
FLOAT
type.
Accessing, adding, and removing masks is done in a simpler way:
The
Mesh.vertex_paint_mask
property returns the attribute
  directly, rather than a collection.
The
Mesh.vertex_paint_mask_ensure()
and
Mesh.vertex_paint_mask_remove()
functions add and remove the
  attribute.
The
Mesh
auto_smooth
property has been replaced by a modifier
  node group asset
  (
89e3ba4e25
### Commit Summary: Mesh: Replace auto smooth with node group ¬∑ 89e3ba4e25 - blender - Blender Projects
### Commit Details:
Design task:
#93551
This PR replaces the auto smooth option with a geometry nodes modifier
that sets the sharp edge attribute. This solves a fair number of long-
standing problems related to auto smooth, simplifies the process of
normal computation, and allows Blender to automatically choose between
face, vertex, and face corner normals based on the sharp edge and face
attributes.

Versioning adds a geometry node group to objects with meshes that had
auto-smooth enabled. The modifier can be applied, which also improves
performance.

Auto smooth is now unnecessary to get a combination of sharp and smooth
edges. In general workflows are changed a bit. Separate procedural and
destructive workflows are available. Custom normals can be used
immediately without turning on the removed auto smooth option.

**Procedural**

The node group asset "Smooth by Angle" is the main way to set sharp
normals based on the edge angle. It can be accessed directly in the add
modifier menu. Of course the modifier can be reordered, muted, or
applied like any other, or changed internally like any geometry nodes
modifier.

**Destructive**
Often the sharp edges don't need to be dynamic. This can give better
performance since edge angles don't need to be recalculated. In edit
mode the two operators "Select Sharp Edges" and "Mark Sharp" can be
used. In other modes, the "Shade Smooth by Angle" controls the edge
sharpness directly.

### Breaking API Changes
- `use_auto_smooth` is removed. Face corner normals are now used
  automatically   if there are mixed smooth vs. not smooth tags. Meshes
  now always use custom normals if they exist.
- In Cycles, the lack of the separate auto smooth state makes normals look
  triangulated when all faces are shaded smooth.
- `auto_smooth_angle` is removed. Replaced by a modifier (or operator)
  controlling the sharp edge attribute. This means the mesh itself
  (without an object) doesn't know anything about automatically smoothing
  by angle anymore.
- `create_normals_split`, `calc_normals_split`, and `free_normals_split`
  are removed, and are replaced by the simpler `Mesh.corner_normals`
  collection property. Since it gives access to the normals cache, it
  is automatically updated when relevant data changes.

Addons are updated here:
blender/blender-addons#104609
### Tests
- `geo_node_curves_test_deform_curves_on_surface` has slightly different
   results because face corner normals are used instead of interpolated
   vertex normals.
- `bf_wavefront_obj_tests` has different export results for one file
  which mixed sharp and smooth faces without turning on auto smooth.
- `cycles_mesh_cpu` has one object which is completely flat shaded.
  Previously every edge was split before rendering, now it looks triangulated.

#108014
-------
).
use_auto_smooth
is removed. Face corner normals are now used
  automatically if there are mixed smooth vs. not smooth tags. Meshes
  now always use custom normals if they exist.
auto_smooth_angle
is removed. Replaced by a modifier (or
  operator) controlling the
"sharp_edge"
attribute. This means the
  mesh itself (without an object) doesn't know anything about
  automatically smoothing by angle anymore.
create_normals_split
,
calc_normals_split
, and
free_normals_split
are removed, and are replaced by the simpler
Mesh.corner_normals
collection property. Since it gives access
  to the normals cache, it is automatically updated when relevant data
  changes.
MeshLoop.normal
is now a read-only property. Custom normals
  should be created by
normals_split_custom_set
or
normals_split_custom_set_from_vertices
.
Material
¬∂
The
displacement_method
property has moved from
cycles.properties.CyclesMaterialSettings
to
bpy.types.Material
a001cf9f2b
### Commit Summary: EEVEE-Next: Displacement Option ¬∑ a001cf9f2b - blender - Blender Projects
### Commit Details:
This add the displacement option to EEVEE materials.
This unifies the option for Cycles and EEVEE.

The displacement only option is not matching cycles
and not particularly useful. So we decided to not
support it and revert to displacement + bump.

#113979
-------
Sequencer
¬∂
Strip transform filter type
SUBSAMPLING_3x3
was renamed to
BOX
.
It affects
bpy.types.SequenceTransform.filter
. (
PR#117584
)
View Layer
¬∂
Add
Scene.view_layers.move()
method to reorder view layers. (
PR#117037
)
Nodes
¬∂
Some nodes (e.g.
Store Named Attribute
)
  use dynamic socket types now instead of having all socket types exist at the same time.
  This means that doing something like
node.outputs[some_index]
does not work the same
  for those nodes anymore.
  Instead use
node.outputs[some_socket_identifier]
which is more reliable.
  (
8149678d5e
### Commit Summary: Geometry Nodes: use dynamic declaration for some nodes ¬∑ 8149678d5e - blender - Blender Projects
### Commit Details:
This changes a bunch of nodes that have a data type drop-down to using a dynamic
node declaration that changes based on the selected data type instead of always having
all sockets. This greatly simplifies the code and is less weird than having suffixes on
socket identifiers.

Backward compatibility and forward compatibility remain due to
#113497
and
#113984
.

One user-visible change is that changing the data type in these nodes does not break
the link anymore.

It may be necessary to bring back some functionality from link-drag-search afterwards.

#113553
-------
)
Grease Pencil Brushes
¬∂
The property
brush.gpencil_settings.direction
has been replaced by
brush.direction
.
  (
998514af7b
### Commit Summary: Fix #115313: GPencil brush direction is not kept ¬∑ 998514af7b - blender - Blender Projects
### Commit Details:
The core of the issue was that `sculpt_flag` was used by three different enums (`eGP_Sculpt_Flag`, `eGP_Sculpt_Mode_Flag`, and `eBrushFlags`). This resulted in the flag getting overriden because `ENUM_OPERATORS` expected the maximum value of `eGP_Sculpt_Flag` to be `(1 << 3)` which it wasn't.

The `sculpt_flag` was exposed through python as `"direction"`.
In the UI this meant that it was effectively used as `brush.direction`. This fix replaces `brush.gpencil_settings.direction` with `brush.direction`.
It also makes sure `sculpt_flag` is only ever used with values from `eGP_Sculpt_Flag`.

#119373
-------
)
Additions
¬∂
Add
Preferences.filepaths.asset_libraries.new/remove
methods
  (
0061f2f650
### Commit Summary: PyAPI: add preferences.filepaths.asset_libraries.new/remove methods ¬∑ 0061f2f650 - blender - Blender Projects
### Commit Details:
Can be convenient to do this from python (e.g. afaict, these preferences
are not used from Application Templates userpref.blend, but could now at
least be configured via the template script __init__.py)

#116381
-------
)
Add
ID.session_uid
read-only property
  (
c68b22cfdf
### Commit Summary: Core: expose ID.session_uid in RNA ¬∑ c68b22cfdf - blender - Blender Projects
### Commit Details:
This exposes the internal `ID.session_uuid` in the Python API as `ID.session_uid`.
The exposed name is not `session_uuid`, because it's not actually universally unique,
and we want to change the internal name too.

The reason for exposing this is to allow Python scripts to call operators that take the
session id as input. A fair number of operators do this as you can see when searching
for `WM_operator_properties_id_lookup`.

#116888
-------
)
Add
NodesModifierBake.bake_id
read-only property
  (
7149424087
### Commit Summary: Geometry Nodes: expose bake id in Python API ¬∑ 7149424087 - blender - Blender Projects
### Commit Details:
This is necessary to be able to invoke baking of individual bake nodes
or simulation zones with Python.
-------
)
Add
NodesModifierBake.node
read-only property
  (
65b722bc30
### Commit Summary: Geometry Nodes: expose NodesModifierBake.node property in Python API ¬∑ 65b722bc30 - blender - Blender Projects
### Commit Details:
This allows scripts to filter the set of bakes by e.g. the node name.
More filtering options will be necessary, but this is a good start.
-------
)
Add
bpy.app.handlers.translation_update_post
update handler that runs when translations change
  (
8564e03cdf
### Commit Summary: Fix FPS menu in "Format" panel not following translation setting ¬∑ 8564e03cdf - blender - Blender Projects
### Commit Details:
The FPS menu was using a cached value which wasn't being refreshed
when translation changed.

Add `bpy.app.handlers.translation_update_post` handler which runs
when translation changes, this can be used to clear any cached UI
values.

Ref
!117049
-------
)
Add optional "frame" & "tile_index" arguments to
Image.scale()
(
3d60209d3d
### Commit Summary: Add an optional "frame" & "tile_index" argument to Image.scale() ¬∑ 3d60209d3d - blender - Blender Projects
### Commit Details:
`BKE_image_scale` -- which is only used for the python API -- was
getting the `ImBuf` without providing an `ImageUser`.
This is fine, but always gets the first tile (and the current frame for sequences).

To resolve this, add an optional "frame" & "tile_index" argument so these can be specified explicitly (similar to layer_index and pass_index already used for some other API functions).
Fixes
#117539
: Scaling UDIM images via Image.scale() only scales one tile

#117549
-------
)
Add
ShapeKey.points
property (
7d77caab9b
### Commit Summary: PyAPI: Add ShapeKey.points for faster foreach_get/set of Mesh shape key data ¬∑ 7d77caab9b - blender - Blender Projects
### Commit Details:
Mesh shape key data elements are always of the `ShapeKeyPoint` type and
only have a `.co` property which is stored contiguously. However, the
`.data` collection property's elements are dynamically typed because
Legacy Curve shape key data elements use a mix of `ShapeKeyCurvePoint`
and `ShapeKeyBezierPoint` elements. The necessary support for handling
the dynamic/mixed typing of the shape key data elements disables raw
access to the collection and its elements which makes `foreach_get`/
`foreach_set` slower.

`ShapeKey.points` is a new collection property whose element type is
fixed as `ShapeKeyPoint` and uses the `#rna_iterator_array_next` and
`#rna_iterator_array_get` collection functions which enable raw access
to the collection.

To complete the raw access to Mesh shape key data, the `.co` property of
`ShapeKeyPoint` also needs raw access. To accomplish this, the RNA
definition for `ShapeKeyPoint` now uses the `#vec3f` DNA struct and its
`.co` property is set to start from the `x` field of the `#vec3f` DNA
struct.

Lattice shape keys also use `ShapeKeyPoint` and also benefit from using
`.points` instead of `.data`, though Lattice objects typically have far
fewer data, such that performance is of minimal concern.

On shape keys belonging to Legacy Curves (`bpy.types.Curve`/
`bpy.types.SurfaceCurve`), `.points` will simply always be empty because
they do not have `ShapeKeyPoint` elements.

---

**Performance**

The increase in performance is specifically for foreach_get/foreach_set,
there is no noticeable performance difference to iterating through or
accessing individual elements of `.points` directly through Python, e.g.
`.points[0].co` vs `.data[0].co`.

`foreach_get` with a Python list is about 2.8 times faster.

`foreach_get` with an incompatible buffer (NumPy ndarray with np.double
dtype) is about 1.4 times faster.

`foreach_get` with a compatible buffer now scales better with larger
collections, so it is about 11.7 times faster at 100 elements and about
200.0 times faster at 100000 elements, dropping off to about 65 times faster for much larger collections.

The increase in `foreach_set` performance is slightly better than in
each `foreach_get` case, but scales the same overall.

`foreach_set` with a Python list is about 3.8 times faster.

`foreach_set` with an incompatible buffer (NumPy ndarray with np.double
dtype) is about 1.45 times faster.

`foreach_set` with a compatible buffer now scales better with larger
collections, so it is about 13.4 times faster at 100 elements and about
220.0 times faster at 100000 elements, dropping off to about 70 times faster for much larger collections.

The performance drop-off might be to do with hardware/OS specifics of `memcpy`. The drop-off occurs for me on Windows 10 with my AMD Ryzen 7 3800X at just above 1.5MiB of data copied (1572888B copied -> 200x faster, 1572900B copied -> 75x faster).

#116637
-------
)
Add access to ordering of links in multi-input socket
  (
8f36281787
### Commit Summary: Nodes: expose ordering of links in multi input socket in Python ¬∑ 8f36281787 - blender - Blender Projects
### Commit Details:
This
fixes
#116096
and is based on
#115249
with some changes.

This patch contains three changes:
* `NodeSocket.links` in the Python API gives the links in the correct order.
* `NodeLink.multi_input_sort_id` gives read-only access to an id that's used
  for sorting. Note that for historical reasons the highest id is the first link.
* `NodeLink.swap_multi_input_sort_id(other_link)` provides a safe way to
  change the order of links connected to a multi-input socket.

Co-authored-by: Adrian Bibby Walther
#118987
-------
)
Shape Key Locks
¬∂
Shape Keys can now be locked by the user to prevent accidental edits in sculpt and edit mode
(
b350d7a4c3
### Commit Summary: Shape Keys: support locking to protect from accidental editing. ¬∑ b350d7a4c3 - blender - Blender Projects
### Commit Details:
It is very common for graphical editors with layers to support
locking individual layers to protect them from accidental edits due
to misclicks. Blender itself already supports locking vertex groups.
This adds lock toggles for shape keys, with lock/unlock all operators.

The flags are checked by sculpt brushes, edit mode transform tools,
and Smooth, Propagate and Blend From Shape operators. This selection
aims to cover operations that only deform the mesh, where the shape
key selection matters.

Topology changing operations always apply to all keys, and thus
incorrect shape key selection is less impactful. Excluding them
from the new feature greatly reduces the patch size.

#104463
-------
).
Add-ons that implement operators that transform the active shape without topology changes,
or invoke other built-in operators that already perform the check,
may consider adding these checks to their own code.
Built-in operator examples:
mesh.vertices_smooth
does the check, because it transforms the active shape.
mesh.subdivide
doesn't check, because it changes topology.
object.transform_apply
doesn't check, because it applies the same transformation to all shapes
  (the active shape key choice doesn't matter).
mesh.polybuild_extrude_at_cursor_move
checks,
  because internally it invokes another operator that does the check.
Example of implementing the check:
from
bpy_extras.object_utils
import
object_report_if_active_shape_key_is_locked
def
execute
(
self
,
context
):
if
object_report_if_active_shape_key_is_locked
(
context
.
object
,
self
):
return
{
'CANCELLED'
}

'''''


9. Blender 4.1: Rendering¬∂

Blender 4.1: Rendering
¬∂
Lights
¬∂
Point and Spot lights have a new Soft Falloff option,
that makes the lights render the same as in Blender 3.6 and earlier.
This behavior is not physically based, but helps avoid sharp boundaries
when the light intersects with other geometry.
The option is enabled by default on new lights.
(
PR#117832
)
Depending on whether Soft Falloff is applied, the light texture behaves differently.
With Soft Falloff, the light radius acts as a blurring factor for the projected texture;
without Soft Falloff, the texture is directly visible on the spherical light source.
Soft Falloff
No Soft Falloff
Shader Nodes
¬∂
Musgrave Texture
¬∂
The Musgrave Texture node was replaced by the Noise Texture node.
Existing shader node setups are converted automatically, and the
resulting renders are identical.
(
0b11c591ec
### Commit Summary: Nodes: Merge Musgrave node into Noise node ¬∑ 0b11c591ec - blender - Blender Projects
### Commit Details:
This path merges the Musgrave and Noise Texture nodes into a single
combined Noise Texture node. The reasoning is that both nodes
intrinsically do the same thing, which is the layering of Perlin noise
derivatives to produce fractal noise. So the patch de-duplicates code
and unifies the use of fractal noise for the end use.

Since the Noise node had a Distortion input and a Color output, while
the Musgrave node did not, those are now available to the Musgrave types
as new functionalities.

The Dimension input of the Musgrave node is analogous to the Roughness
input of the Noise node, so both inputs were unified to follow the same
behavior of the Roughness input, which is arguable more intuitive to
control. Similarly, the Detail input was slightly different across both
nodes, since the Noise node evaluated one extra layer of noise. This was
also unified to follow the behavior of the Noise node.

The patch, coincidentally fixes an unreported bug causing repeated
output for certain noise types and another floating precision bug
#112180
.

The versioning code implemented with this patch ensures backward
compatibility for both the Musgrave and Noise Texture nodes. When
opening older Blender files in Blender 4.1 the output of both nodes are
guaranteed to always be exactly identical to that of Blender files
created before the nodes were merged in all cases.

Forward compatibility with Blender 4.0 is implemented by
#114236
.
Forward compatibility with Blender 3.6 LTS is implemented by
#115015
.

#111187
-------
)
The Dimension input is replaced by a Roughness input, where
Roughness = power(Lacunarity, -Dimension)
.
The Detail input value must be subtracted by 1 compared to the old
  Musgrave Texture node.
By being part of the Noise Texture node, the Musgrave modes gain support
for the Distortion input and Color output.
Node setup to convert Dimension to new Roughness
Hydra
¬∂
Support rendering particle system hair, in addition to the existing
  geometry node hair curves (
9a7ea993d0
### Commit Summary: Hydra: Support legacy hair particle curves ¬∑ 9a7ea993d0 - blender - Blender Projects
### Commit Details:
Ref
#110765
Co-authored-by: Bogdan Nagirniak
Co-authored-by: Brecht Van Lommel
#114197
-------
).
Improved support for shader conversion to MaterialX, including math node
  (
e5b7768830
### Commit Summary: MaterialX: Add remaining float/vector math operations ¬∑ e5b7768830 - blender - Blender Projects
### Commit Details:
Ref
#112864
#117764
-------
).
Exports of large meshes has been parallelized, giving
  up to a 6x speedup depending on the scene and hardware
  (
75f24a5f14
### Commit Summary: Hydra: Parallelize and simplify submesh export ¬∑ 75f24a5f14 - blender - Blender Projects
### Commit Details:
- Only calculate normals on the necessary domain
- Functions for exporting generic data
- Parallelize export of multiple submeshes
- Parallelize export within a single submesh
- Resize vectors to correct size to avoid reallocation
- Simplify hot loops to improve performance
- Optimize single material case to avoid index remapping

`write_submeshes` timing information (average of many runs)
| Test                           | Before    | After     |
| ------------------------------ | --------- | --------- |
| 6 million vert mesh            | 791.99 ms | 130.75 ms |
| 1.5 million vert 100 materials | crash     | 48.27 ms  |
| Mr. Elephant test file         | 778.95 ms | 277.06 ms |

#113412
-------
).

'''''


10. Blender 4.1: Sculpting¬∂

Blender 4.1: Sculpting
¬∂
Voxel remesh attribute preservation has been changed to propagate
all
attributes and to improve performance
  (
ba1c8fe6a5
### Commit Summary: Mesh: Improve remesh attribute transfer ¬∑ ba1c8fe6a5 - blender - Blender Projects
### Commit Details:
Currently we have options to transfer the paint mask, face sets, and
color attributes to the new mesh created by voxel remesh. This doesn't
make use of the generic attribute design, where it would be clearer to
transfer all attributes with the same methods. That's reflected in the
code as well-- we do duplicate work for the mask and vertex colors, for
example.

This commit replaces the transfer options with a single checkbox for
all attributes. All attribute types on all domains are transferred with
basically the same method as the "Sample Nearest" node from geometry
nodes-- they take the value from the nearest source element of the same
domain. Face corners are handled differently than before. Instead of
retrieving the mixed value of all the corners from the nearest source
vertex, the value from the nearest corner of the nearest face.

---

Some timing information, showing that when interpolating the same
data, the attribute propagation is significantly faster than before.
Edge and corner attributes would add some cost (edges more than
corners), but might not always be present.

Before
```
voxel_remesh_exec: 3834.63 ms
BKE_shrinkwrap_remesh_target_project: 1141.17 ms
BKE_mesh_remesh_reproject_paint_mask: 689.35 ms
BKE_remesh_reproject_sculpt_face_sets: 257.14 ms
BKE_remesh_reproject_vertex_paint: 54.64 ms
BKE_mesh_smooth_flag_set: 0.15 ms
```

After
```
voxel_remesh_exec: 3339.32 ms
BKE_shrinkwrap_remesh_target_project: 1158.76 ms
mesh_remesh_reproject_attributes: 517.52 ms
```

#115116
-------
).
Add brush settings for view and normal automasking values
  (
1e4f133950
### Commit Summary: Sculpt: Add brush settings for view & normal automasking values ¬∑ 1e4f133950 - blender - Blender Projects
### Commit Details:
This pull request adds the ability for the `Limit` and `Falloff` values for the View and Normal automask modes to be applied per-brush instead of modifying the global tool value.

Previously, while the flag settings were stored at the brush and global level, the values would always change the global value even when using the advanced tab of the brush menu.

## Testing
* `make test` results in 3 failures (49 - io_wavefront, 134 - compositor_distort_cpu, 323 - imbuf_save), but these tests appear to fail even prior to any changes being applied when running locally
* Manual testing with older version blend files to ensure that the value is defaulted correctly.
* Visual testing to verify that brush values are favored over global values.

Addresses
#115174
#117433
-------
).
Add brush setting for input samples
  (
a2b3fe5e01
### Commit Summary: Sculpt: Add per-brush input samples ¬∑ a2b3fe5e01 - blender - Blender Projects
### Commit Details:
This pull request adds the ability for users to specify input samples
on a per brush basis. The existing field in the main `Paint` struct
forces all brushes of a particular tool type to use the same value.
A new field was added to the `Brush` struct to allow for this value
to be specified there instead, and a corresponding unified value in
`UnifiedPaintSettings` has been created to allow users to use the
same value across all brushes.

Addresses
#108109
#117080
-------
).
Add scene setting for automasking propagation step value
  (
c61d1bcb54
### Commit Summary: Sculpt: Add global automasking propagation steps ¬∑ c61d1bcb54 - blender - Blender Projects
### Commit Details:
This pull request adds the ability for the `propagation_steps` value
for certain automasking settings to be applied globally instead of
using the per-brush attribute.

Previously, while the flag settings were stored at the brush and global
level,  the `propagation_steps` value would always change the brush
attribute even when using the global menu.

Addresses
#102377
#117316
-------
).

'''''


11. Blender 4.1: Sequencer¬∂

Blender 4.1: Sequencer
¬∂
Performance
¬∂
The video Sequencer got many performance optimizations across the board.
Timeline user interface repaints 3x-4x faster for complex timelines.
(
df16f4931e
### Commit Summary: VSE: speedup timeline drawing, and improve waveform display ¬∑ df16f4931e - blender - Blender Projects
### Commit Details:
Sequencer timeline UI repainting is 3x-4x faster now, for complex
timelines. On Sprite Fright Edit data set, with whole timeline visible
(2702 strips), repainting the timeline UI with all overlay options
(waveforms, offsets, thumbnails etc.):

- Windows (Ryzen 5950X, RTX 3080Ti, OpenGL): 62ms -> 18.6ms (16FPS -> 54FPS)
- Mac (M1 Max, Metal): 39.8ms -> 11.5ms (25FPS -> 86FPS)

This is achieved by:

- Avoiding tiny GPU draw calls (i.e. drawing one quad a time), instead
  batch all the quads / lines needed by the timeline display into
  series of about-1000 quads per draw.
- For retiming keys display, batch their keyframe point drawing too.
- For audio waveform overlay display, change it to draw batched quads
  instead of alternating between line strips and triangle strips. This
  actually changes how the waveform looks like (implements
#115274
)
  and fixes some visual issues with waveforms too.
- For fcurve overlays, also draw them as batched quads.

While at it, this also fixes an issue where while dragging strips over
other strips, their text labels would look as if they are behind the
background strips.

#115311
-------
)
Effects: Glow is 6x-10x faster (
fc64f48682
### Commit Summary: VSE: make Glow effect 6x-10x faster ¬∑ fc64f48682 - blender - Blender Projects
### Commit Details:
Glow effect was doing the correct thing algorithmically (separable gaussian
blur), but it was 1) completely single-threaded, and 2) did operations in
several passes over the source images, instead of doing them in one go.

- Adds multi-threading to Glow effect.
- Combines some operations, e.g. instead of IMB_buffer_float_from_byte
  followed by IMB_buffer_float_premultiply, do
  IMB_colormanagement_transform_from_byte_threaded which achieves the same,
  but more efficiently.
- Simplifies the code: removing separate loops around image boundaries is
  both less code and slightly faster; use float4 vector type for more
  compact code; use Array classes instead of manual memory allocation, etc.
- Removes IMB_buffer_float_unpremultiply and IMB_buffer_float_premultiply
  since they are no longer used by anything whatsoever.

Applying Glow to 4K UHD sequencer output, on Windows Ryzen 5950X:
- Blur distance 4: 935ms -> 109ms (8.5x faster)
- Blur distance 20: 3526ms -> 336ms (10.5x faster)

Same on Mac M1 Max:
- Blur distance 4: 732ms -> 126ms (5.8x faster)
- Blur distance 20:  3047ms -> 528ms (5.7x faster)

#115818
-------
), Wipe is 6x-20x
faster (
06370b5fd6
### Commit Summary: VSE: make Wipe effect 6x-20x faster ¬∑ 06370b5fd6 - blender - Blender Projects
### Commit Details:
Wipe effect was completely single threaded. So multi-thread that.
Additionally, simplify math done in Clock wipe code; asin() + hypot()
+ some checks is just atan2() really.

Applying Wipe to 4K UHD sequencer output, on Windows Ryzen 5950X:
- Single/Double: 99.1 -> 9.3 ms (10.6x faster)
- Iris: 153.3 -> 12.3 ms (12.4x faster)
- Clock: 301.4 -> 14.5 ms (20.8x faster)

The same on Mac M1 Max:
- Single: 74.5 -> 13.4 ms (5.6x faster)
- Iris: 84.2 -> 14.3 ms (5.9x faster)
- Clock: 185.3 -> 18.8 ms (9.8x faster)

#115837
-------
), Gamma Cross is 4x faster
(
9cbc96194e
### Commit Summary: VSE: make Gamma Cross effect 4x faster ¬∑ 9cbc96194e - blender - Blender Projects
### Commit Details:
Gamma Cross code seems to be coming from year 2005 or earlier, with complex
table based machinery to approximate "raise to power" calculations. Which,
for Gamma Cross, have always been hardcoded to 2.0 "since forever". So
simplify all that, i.e. replace all the table lookup/interpolation things
with just `x*x` and `sqrt(x)`.

Applying Gamma Cross on 4K UHD resolution, Windows Ryzen 5950X machine:
36.2ms -> 8.1ms

#115801
-------
), Gaussian Blur is 1.5x faster
(
5cac8e2bb4
### Commit Summary: VSE: reduce effects code duplication, making gaussian blur faster in the process ¬∑ 5cac8e2bb4 - blender - Blender Projects
### Commit Details:
Now that the code is in C++, quite some duplication between "byte" and
"float" effect code paths can be reduced (easier than it was in C times).
So I did that, removing about 400 lines of code.

In that process I accidentally made Gaussian Blur faster, since while
reducing the amount of code I noticed it was doing some things
sub-optimally (calculated kernel tables for each job, etc.). Applying
100x100 gaussian blur on 4K UHD resolution image strip on Ryzen 5950X
went 630ms -> 450ms.

#116089
-------
), Solid Color is 2x faster (
PR#117058
).
Various parts of image transformation (
1e0bf33b00
### Commit Summary: ImBuf: optimize IMB_transform ¬∑ 1e0bf33b00 - blender - Blender Projects
### Commit Details:
IMB_transform is used by Sequencer (and other places) to do image
translation/rotation/scale on the CPU. This PR speeds up parts of it,
particularly when bilinear filtering is used. No behavior changes are
expected.

- Don't use virtual function calls inside inner loop. The code was using
  class hierarchies with virtual calls just to do equivalent of "outside
  of image? ignore" and "wrap UV coordinates or not?" decisions. Make those
  use non-virtual function based code.
- Simplify pixel sampling functions to only do the work as needed by
  anything within Blender codebase. For example, bilinear sampling of uchar
  images always uses 4 RGBA channels and never does "UV wrap" logic.
- Bilinear interpolation uchar: completely branchless SIMD code now.
- Bilinear interpolation float: 2x floor() calls instead of 4x floor() +
  2x ceil(), and final sample blending is done with SIMD.

Sequencer at 4K UHD resolution, with two image strips that need a transform,
playback framerate:

- Windows Ryzen 5950X: 18.7fps -> 26.2fps (IMB_transform time per frame goes
  26.3ms -> 11.2ms)
- Mac M1 Max: 27.3fps -> 31.4fps

At that point the IMB_transform is not the slowest part of where playback
takes time (but rather sequencer effect application etc.).

Note: the amount of _actual code_ got a bit smaller. But I've added 100 lines
of unit tests in BLI_math_interp_test.cc, the bilinear interpolation
functions were only tested very indirectly by CPU compositor template
image tests.

#115653
-------
,
PR#117125
), movie
frame reading and writing (
422dd9404f
### Commit Summary: ffmpeg: multithreaded conversion from RGBA into encoding format ¬∑ 422dd9404f - blender - Blender Projects
### Commit Details:
Whenever movie frame encoding needs to be in non-RGBA format (pretty much
always, e.g. H.264 uses YUV etc.), the ffmpeg code has been using
sws_scale() since 2007. But that one is completely single threaded.

It can be multi-threaded by passing "threads" option to SwsContext
(in a cumbersome way), combined with sws_scale_frame API. Which however
requires frame data buffers to be allocated via AVBuffer machinery.

Rendering a 300-frame part of Sprite Fright Edit (target H.264 Medium):

- Windows Ryzen 5950X: 16.1 -> 12.0 seconds (generate_video_frame part
  4.7 -> 0.7 sec).
- Mac M1 Max: 13.1 -> 12.5 sec. Speedup is smaller, but comparatively,
  entirely other part of movie rendering (audio resampling inside audaspace)
  is way more expensive compared to the windows machine.
-------
,
4ef5d9f60f
### Commit Summary: ffmpeg: optimize ffmpeg_postprocess ¬∑ 4ef5d9f60f - blender - Blender Projects
### Commit Details:
After doing regular movie frame decoding, there's a "postprocess" step for
each incoming frame, that does deinterlacing if needed, then YUV->RGB
conversion, then vertical image flip and additional interlace filtering if
needed. While this postprocess step is not the "heavy" part of movie
playback, it still takes 2-3ms per each 1080p resolution input frame that
is being played.

This PR does two things:
- Similar to
#116008
, uses multi-threaded `sws_scale` to do YUV->RGB
  conversion.
- Reintroduces "do vertical flip while converting to RGB", where possible.
  That was removed in
2ed73fc97e
due to issues on arm64 platform, and
  theory that negative strides passed to sws_scale is not an officially
  supported usage.

My take on the last point: negative strides to sws_scale is a fine and
supported usage, just ffmpeg had a bug specifically on arm64 where they
were accidentally not respected. They fixed that for ffmpeg 6.0, and
backported it to all versions back to 3.4.13 -- you would not backport
something to 10 releases unless that was an actual bug fix!

I have tested the glitch_480p.mp4 that was originally attached to the
bug report
#94237
back then, and it works fine both on x64 (Windows)
and arm64 (Mac).

Timings, ffmpeg_postprocess cost for a single 1920x1080 resolution movie
strip inside VSE:
- Windows/VS2022 Ryzen 5950X: 3.04ms -> 1.18ms
- Mac/clang15 M1 Max: 1.10ms -> 0.71ms

#116309
-------
), color management (
f3ce0645e4
### Commit Summary: Color management: multi-thread IMB_colormanagement_transform_from_byte_threaded simple case ¬∑ f3ce0645e4 - blender - Blender Projects
### Commit Details:
This function is only used in Sequencer code to convert source byte images
into float images. For a "simple case" where there is no color space
conversion needed, it was doing that on a single thread, in two passes over
the image (first byte -> float conversion, then alpha premultiply).

VSE 4K resolution playback, with two image strips where one of them has
"convert to float" option, on Windows / Ryzen 5950X:

- Overall playback FPS: 3.40 -> 4.03. Still very slow, and a lot of time
  is spent in allocating, clearing and deleting various temp images, as
  well as final color conversion for display.
- `seq_imbuf_to_sequencer_space` part: 217.9ms -> 86.6ms. Most of
  remaining cost is just in just memory allocation+clear, which is why
  it's not drastically faster due to threading.

#115628
-------
) and
audio resampling (
986f493812
### Commit Summary: Audaspace: faster audio resampling ¬∑ 986f493812 - blender - Blender Projects
### Commit Details:
Previously in Audaspace there was choice between linear resampler (okay
for preview, but not great for final mix), or "extremely high quality
preset" for rendering the final mix; with nothing in between. I have just
landed "medium" and "low" resampler quality levels in upstream Audaspace
(see
https://github.com/audaspace/audaspace/pull/18
with details and
quality spectograms, also comparison with Audacity resampler).

This PR updates Audaspace to latest upstream, and switches to use the newly
added "medium" quality resampler. There's no audible difference (nor visible
one in spectrograms), as far as I can tell.

Timings, rendering out frames 1000-3000 of Sprite Fright Edit blender
studio data set:
- Windows (Ryzen 5950X, VS2022): 92 -> 73 sec
- Mac (M1 Max, clang 15): 70 -> 62 sec

i.e. using a faster audio resampler makes the _whole render process_ be
10-20% faster (however, this from VSE where it combines already pre-rendered
image strips).

#116059
-------
) were sped up.
Luma Waveform display calculation is 8x-15x faster
(
93ca2788ff
### Commit Summary: VSE: speedup Luma Waveform display output mode ¬∑ 93ca2788ff - blender - Blender Projects
### Commit Details:
Use multithreading, plus make the non-float / non-separate luma
calculations faster by avoiding byte->float->byte conversions
back and forth.

On a 4K resolution sequencer display, time taken to calculate the
waveform (Windows, Ryzen 5950X):

- regular images: 127.0ms -> 6.4ms
- regular images, separate colors: 160.3ms -> 13.1ms
- float images: 86.2ms -> 11.1ms
- float images, separate colors: 162.9ms -> 17.4ms

This also fixes curious "one black pixel row" in the middle of the
waveform, which was caused by the code spreading 256 possible luma
values over "off by one" vertical range:

#115579
-------
).
Filtering
¬∂
Image/movie filtering that is done when scaling/rotating strips has been improved.
Default strip filter is now "Auto", which automatically chooses the most appropriate
  filter based on scaling factors (
PR#117853
):
No scale/rotation and integer positions use Nearest,
Scaling up by more than 2x uses Cubic Mitchell,
Scaling down by more than 2x uses Box,
Otherwise Bilinear.
Strip transforms got Cubic filter option, previously it only
  existed in Transform Effect strip (
PR#117100
,
PR#117517
).
  Cubic filter exists in B-Spline (matches cubic elsewhere in Blender) and Mitchell
  (usually better for images) varieties. Cubic filtering is also faster now.
Bilinear filter no longer adds a transparent edge near image border when scaling it up.
  (
PR#117717
)
Subsampled3x3 filter was replaced by a more general Box filter, that better handles
  scaling images down by more than 3x. (
PR#117584
)
Various "off by one pixel" issues resulting in gaps between neighboring strips,
  or images being shifted by half a pixel, have been solved. (
PR#116628
)
Scopes
¬∂
Sequencer Scopes got visual look improvements (
PR#116798
):
Left is Blender 4.0, right is Blender 4.1:
Histogram
Waveform (Luma)
Waveform (Parade)
Vectorscope
Audio
¬∂
Audio waveforms are now displayed by default, and
  got a display option to show upper half of the waveform only.
  (
a95dd8438d
### Commit Summary: VSE: add option to display half of audio waveform ¬∑ a95dd8438d - blender - Blender Projects
### Commit Details:
Default is "full" waveform display. Adds overlay option to display absolute
value of the signal as upper half only. Part of design task
#115274
#116344
-------
) (
1be8b51b11
### Commit Summary: VSE: display audio waveforms by default ¬∑ 1be8b51b11 - blender - Blender Projects
### Commit Details:
As outlined in
#115274
design task, at this point VSE timeline audio
waveform processing/rendering is no longer a performance issue,
so make it on by default.

#116334
-------
)

'''''


12. Blender 4.1: User Interface¬∂

Blender 4.1: User Interface
¬∂
General
¬∂
Input Placeholders to show a hint about the expected value of an
  input.
  (
b0515e34f9
### Commit Summary: UI: Input Placeholders ¬∑ b0515e34f9 - blender - Blender Projects
### Commit Details:
Optional inline hint describing the expected value of an input field.

#112104
-------
).
Cryptomatte picking can now occur between separate windows.
  (
9ee5de05c0
### Commit Summary: Fix #101058: Allow Cryptomatte Picking Between Windows ¬∑ 9ee5de05c0 - blender - Blender Projects
### Commit Details:
Allow the source and target windows to differ when selecting
objects using Cryptomatte.

#113636
-------
).
The UI interface font can now be shown in any weight.
  (
0bde01eab5
### Commit Summary: UI: Configurable UI Font Weight ¬∑ 0bde01eab5 - blender - Blender Projects
### Commit Details:
Allows selecting different font weights in Text Styles

#112454
-------
).
Khmer font added to support a new translation of that Cambodian
  language.
  (
3f5654b491
### Commit Summary: Fix #114080: Add Khmer Font ¬∑ 3f5654b491 - blender - Blender Projects
### Commit Details:
Add Noto Sans Khmer (variable) font, needed for new translation.
-------
).
New icons added to represent area splitting, joining, and swapping.
  (
153dd76d22
### Commit Summary: UI: Icons for Horizontal and Vertical Split ¬∑ 153dd76d22 - blender - Blender Projects
### Commit Details:
Adding new icons to represent horizontal and vertical area splitting.

#114433
-------
,
8933284518
### Commit Summary: UI: Icons for Area Join and Swap ¬∑ 8933284518 - blender - Blender Projects
### Commit Details:
Icons provided by Alexey Adamitsky to represent screen area join and
screen area swap.

#115712
-------
).
Wide Enum lists will now collapse to a single column if not enough
  space.
  (
83ce3ef0db
### Commit Summary: Fix #72093: Collapse Wide Enum Lists to One Column ¬∑ 83ce3ef0db - blender - Blender Projects
### Commit Details:
If a multi-column Enum menu gets too wide for the available space,
collapse it to a single column.

#105386
-------
).
Changing UI font in Preferences will now start in your OS Fonts
  folder.
  (
d3a2673cb8
### Commit Summary: Fix #102714: Interface Font Selection ¬∑ d3a2673cb8 - blender - Blender Projects
### Commit Details:
When selecting fonts for the interface, show thumbnails
and start in the user-specified fonts directory

#113259
-------
,
048cece74d
### Commit Summary: UI: Show folders when selecting font ¬∑ 048cece74d - blender - Blender Projects
### Commit Details:
On some systems, fonts may be categorized in folders, in which case user
sees nothing by default.

#117389
-------
).
File Browser List View removes columns and reformats as width is
  decreased.
  (
07820b0703
### Commit Summary: UI: File Browser Display Narrowing ¬∑ 07820b0703 - blender - Blender Projects
### Commit Details:
Change the format of columns, and remove columns, as the File Browser
window narrows.

#112464
-------
).
Improved Color Picker cursor indication and feedback.
  (
c11d5b4180
### Commit Summary: UI: Color Picker Position Indication ¬∑ c11d5b4180 - blender - Blender Projects
### Commit Details:
Changes to how the current positions in the color picker are shown.

#113753
-------
).
Text Object fonts now look in the fallback stack when characters are
  not found.
  (
604ee2d036
### Commit Summary: VFont: Use BLF for font & glyph loading ¬∑ 604ee2d036 - blender - Blender Projects
### Commit Details:
Load VFont curves using BLF API rather than local FreeType calls.

#110187
-------
).
Animation marker drawing improvements.
  (
0370feb1bf
### Commit Summary: Anim: Marker Drawing Changes ¬∑ 0370feb1bf - blender - Blender Projects
### Commit Details:
Don't draw marker line through marker. Draw Selected markers in a color
that matches selected line and text.

#115252
-------
).
Improved corner rounding for menus and popup blocks.
  (
42ddc13033
### Commit Summary: Fix #95709: Improve pulldown menu corner rounding ¬∑ 42ddc13033 - blender - Blender Projects
### Commit Details:
Improve corner rounding of menus and popup blocks.

#111554
-------
).
Improved quality of menu and popup block shadows.
  (
0335b6a3b7
### Commit Summary: UI: Improve menu dropshadow ¬∑ 0335b6a3b7 - blender - Blender Projects
### Commit Details:
Improvements to the drawing of shadows, used with blocks, menus, nodes,
etc. Improvements to shape, especially at the top corner or at extremes
of widget roundness. Allows transparent objects to have shadows. This
is a nice refactor that removes a lot of code.

#111794
-------
).
Improved initial display of compositor node trees.
  (
ff083c1595
### Commit Summary: Compositor: UI: better node visibility for  default node tree ¬∑ ff083c1595 - blender - Blender Projects
### Commit Details:
Create default compositor node tree centred around x-axis, and with lower y-offset for better visibility

#115439
-------
).
New Text Objects will use translated "Text" as default.
  (
5e38f7faf0
### Commit Summary: I18n: translate new text object body ¬∑ 5e38f7faf0 - blender - Blender Projects
### Commit Details:
After VFont has been updated to use the BLF API in
604ee2d036
, it can
use the fallback font stack and display text in many scripts.

This change means the default text for font objects can now be
translated, instead of always being the English word 'Text'.
Translation will only occur if the user has enabled translation of new
data in the preferences.
-------
).
Eyedropper can now pick colors outside the Blender window on Mac.
  (
639de68aaa
### Commit Summary: Fix eyedropper outside blender on mac ¬∑ 639de68aaa - blender - Blender Projects
### Commit Details:
Support for picking colors from outside of the blender window on macOS

#115187
-------
).
Open Recent menu items now show blender version and thumbnail if available.
(
0b0e0601a1
### Commit Summary: UI: Recent Menu Previews ¬∑ 0b0e0601a1 - blender - Blender Projects
### Commit Details:
Recent Menu item tooltips showing details and preview image.

#112644
-------
).
Open Recent menu now includes "Clear Recent Files List" item.
(
1ccc958150
### Commit Summary: UI: Improved Confirmation Dialog for Clear Recent List ¬∑ 1ccc958150 - blender - Blender Projects
### Commit Details:
Add a nicer, more informative confirmation dialog to the recently-added
operator that clears the Recent File List.

#116796
-------
).
Background Images can now be shown with render color transforms applied.
(
29b1658124
### Commit Summary: UI: View As Render for Background Images ¬∑ 29b1658124 - blender - Blender Projects
### Commit Details:
Add checkmark for "View as Render" to background
images in Properties / Camera data.

#115120
-------
).
File Browser tooltips now show blender version, image dimensions, video
details, etc. (
cd4328dd82
### Commit Summary: UI: Dynamic File Browser Tooltips ¬∑ cd4328dd82 - blender - Blender Projects
### Commit Details:
Show tooltips in File Browser (both in thumbnail and list views) that
provide extra information and vary by type, like video resolution and
frames, etc.

#104547
-------
).
Some changes and corrections to the Text Object "Special Characters" menu.
(
0251701cd6
### Commit Summary: Fix #116252: Corrections to Text Object Special Characters Menu ¬∑ 0251701cd6 - blender - Blender Projects
### Commit Details:
Small Corrections to the items on the Text / Special Characters menu.

#116677
-------
).
Clarify Liquid Diffusion/Viscosity Properties
  (
67b21ce54d
### Commit Summary: UI: Clarify Liquid Diffusion/Viscosity Properties ¬∑ 67b21ce54d - blender - Blender Projects
### Commit Details:
The viscosity panel was confusing for users because viscosity
is defined by the base and exponent properties in the Diffusion panel.

What this setting actually does is use a special solver algorithm that is designed for high viscosity liquids.
See
635694c0ff
for details.

The below changes are designed to better represent this to the user.

- Move the "Viscosity" Panel to a sub panel of "Diffusion"
- Rename "Viscosity" to "High Viscosity Solver" to better represent what this property does
- Update `use_viscosity` tooltip to better explain that this uses a different solver algorithm.

#116118
-------
).
The auto-save timer is now restarted after saving manually
  (
f0f304e240
### Commit Summary: WM: restart auto-save timer when saving manually ¬∑ f0f304e240 - blender - Blender Projects
### Commit Details:
When auto-save is slow it can be very intrusive because it freezes Blender at
unexpected times. Often people have a habit of saving frequently anyway, even
more often than auto-save would. In this case it seems unnecessary to auto-save
as well.

This patch restarts the auto-save timer when the user is saving manually to avoid
the unexpected freeze in many cases.

#117690
-------
).
Dialog to enter characters by Unicode value into Text Objects.
  (
6d357dc60d
### Commit Summary: UI: Dialog to Insert Unicode Characters for Text Objects ¬∑ 6d357dc60d - blender - Blender Projects
### Commit Details:
Dialog box that allows the entry of any Unicode character into a 3D
Text Object string by entering its hexadecimal codepoint value.

#116966
-------
).
Operator Properties dialogs now include "Cancel" button.
  (
0d6aec1c21
### Commit Summary: UI: Operator Props Dialog Changes ¬∑ 0d6aec1c21 - blender - Blender Projects
### Commit Details:
Changes to WM_operator_props_dialog_popup to allow configuration,
including via python, and with a look consistent with new confirms.

#117528
-------
).
All disclosure open/close items now using the same chevron-style icon.
  (
8d48770418
### Commit Summary: UI: Consistent Use of Chevron Disclosure Icons ¬∑ 8d48770418 - blender - Blender Projects
### Commit Details:
For icons that represent collapsible and collapsed content we use a
variety of icons: chevrons and closed triangles of varying
proportions. This PR makes everything use a chevron for consistency.

#116240
-------
).
Updated general Mask icon and Grease Pencil "Invert" icons.
  (
f3c401ef6f
### Commit Summary: UI: Update default mask icon ¬∑ f3c401ef6f - blender - Blender Projects
### Commit Details:
Based on the design of
#102585
, This PR replaces the MOD_MASK icon with
the CLIP_UVDEHLT icon to better communicate the intent of masking across
many areas of Blender. It also changes the Grease Pencil `invert` icons
to avoid conflicts with the CLIPUV_DEHLT & CLIPUV_HLT.

#117467
-------
).
Added visual toggle for Sculpt and Grease Pencil automasking options.
  (
c15d1b8ccb
### Commit Summary: UI: Add visual indicator for automasking state ¬∑ c15d1b8ccb - blender - Blender Projects
### Commit Details:
This adds a visual toggle for sculpt automasking in both regular and Grease Pencil modes.

If no automasking settings are used, use the icon `CLIPUV_DEHLT`, otherwise it is CLIPUV_HLT.
As it was agreed on in
#117467
Addresses
#102585
#117649
-------
).
Image Editor
¬∂
Image Editor now allows rotating images by 90 degree increments.
  (
93562a1cc5
### Commit Summary: UI: Image Rotate ¬∑ 93562a1cc5 - blender - Blender Projects
### Commit Details:
Operator to rotate images in 90 degree increments.

#117352
-------
).
Image Vectorscope has updated look, and ability to display tinted or luma scope.
  (
567455124d
### Commit Summary: UI: Image Editor Vectorscope Improvement ¬∑ 567455124d - blender - Blender Projects
### Commit Details:
Update the look of image editor Vectorscope widget (design
#116973
):
- Colored and Luma options for the point cloud,
- The circles are no longer very low poly,
- Overall grid/background colors are tuned.
- Primary color locations have text labels.

Images in the PR.

#116974
-------
).
Node Editor
¬∂
The
Ungroup
operator now ungroups all selected group nodes instead
  of just the active one
  (
f3cd25370c
### Commit Summary: Nodes: ungroup all selected group nodes instead of just the active one ¬∑ f3cd25370c - blender - Blender Projects
### Commit Details:
It's useful to be able to ungroup multiple groups at once when trying to
see how much complexity there is in a node setup.
-------
).
Socket picking when creating node links has been improved to reduce
  the number of mis-clicks
  (
74dd1e044b
### Commit Summary: Nodes: improve socket picking tolerances ¬∑ 74dd1e044b - blender - Blender Projects
### Commit Details:
The goal here is to make it easier to make node links. Previously, it was quite
easy to accidentally start box selection or to trigger the link-drag-search when
that was not intended.

Now, the tolerances are a bit easier to work with. Also, instead of trying to use
the first socket that is close enough, it will find the closest socket instead. It feels
much better in my testing already, but obviously the values can be tuned more
with some testing.

Also we have to make sure to not accidentally make other things like resizing
nodes harder.

#115010
-------
).
Outliner
¬∂
Double-click on Outliner collection to select all children. (
796577d76e
### Commit Summary: Outliner: Double-click on item icon to select contents/hierarchy ¬∑ 796577d76e - blender - Blender Projects
### Commit Details:
Allow double-clicking on Outliner items to select all child items.

#110151
-------
).
Modifiers can now be applied from the outliner (
1c503c094c
### Commit Summary: Outliner: Add option to apply object modifier ¬∑ 1c503c094c - blender - Blender Projects
### Commit Details:
In discussions about
#93551
, some users mentioned it would be helpful
to have the ability to apply modifiers from the outliner. Adding that
ability is quite simple, and it makes sense since we already have the
option to remove modifiers there.

---

![image](/attachments/e64c0dd4-a6ec-4115-a46b-7d2fca487c07)

#117349
-------
).
Outliner context menu contains "Show Hierarchy" and "Expand/Collapse All".
  (
4793b4592b
### Commit Summary: Outliner: clarify "Show Hierarchy" context menu entry ¬∑ 4793b4592b - blender - Blender Projects
### Commit Details:
Display OUTLINER_OT_show_hierarchy as "Show Object Hierarchy"

#114139
-------
,
f815484e7d
### Commit Summary: Outliner: add "Expand/Collapse All" to view context menu ¬∑ f815484e7d - blender - Blender Projects
### Commit Details:
This was only in the blender keymap, but seems useful to have this in a
menu as well.

#114138
-------
).
3D Viewport
¬∂
Walk mode now supports relative up/down (using R/F keys)
  (
c62009a6ac
### Commit Summary: 3D View: add local up/down movement to walk navigation ¬∑ c62009a6ac - blender - Blender Projects
### Commit Details:
Minor usability enhancement for the walk navigation mode. Previously
walk navigation had local movement for forward/back/left/right,
but only global movement for up/down.
This PR adds local up/down movement, bound to the R and F keys.

Ref:
!111682
-------
).
Improved Mesh Edge Highlighting.
  (
dfd1b63cc7
### Commit Summary: UI: improve mesh edge highlighting ¬∑ dfd1b63cc7 - blender - Blender Projects
### Commit Details:
Changes to edit mode mesh overlays, use hue shift instead of color
fading/darkening for selection mode visual differentiation, and some
theme changes to improve the display of mesh edges and faces with good
selection visibility.

- Removed "edge" toggle from edit mode overlays panel.
- No longer halves the edge and face alpha depending on selection mode.
  Half the face alpha in wire-frame mode. For better visibility on most
  themes.

Ref
!111431
-------
).
Improved contrast for text overlays. (
a4a8683788
### Commit Summary: UI: Increased Overlay Text Contrast ¬∑ a4a8683788 - blender - Blender Projects
### Commit Details:
Increased contrast of light text on any background by increasing the
effectiveness of the dark shadow.

#117351
-------
).
Shadowed text for Geometry Nodes Viewer attributes. (
38e7b4e473
### Commit Summary: Geometry Nodes: Improve attribute text overlay readability ¬∑ 38e7b4e473 - blender - Blender Projects
### Commit Details:
Improve readability for GN Viewer Node attribute text by adding text
shadow. Also adds similar shadow for bone names.

#116528
-------
).
Gizmo button to toggle Lock Camera to View. (
23faaac68b
### Commit Summary: UI: Gizmo Button for Lock Camera to View ¬∑ 23faaac68b - blender - Blender Projects
### Commit Details:
3DView 2D gizmo navigation button to toggle "Lock Camera to View".

#111076
-------
).
Linux
¬∂
Input Method Editors (IME) now supported for Wayland
  (
a38a49b073
### Commit Summary: GHOST/Wayland: IME support using the text-input protocol ¬∑ a38a49b073 - blender - Blender Projects
### Commit Details:
Tested with IBUS on GNOME 45.
Added a capabilities flag to GHOST since support for IME works on
Wayland but not on X11, so runtime detection is needed.
-------
).

'''''


13. Blender 4.1: Add-ons¬∂

Blender 4.1: Add-ons
¬∂
Rigify
¬∂
Nested bone collections are now supported by the Rig Layers UI: when a parent
  collection is hidden, buttons for its children are greyed out.
  (
69f9e45f7b
)
Some custom properties now use recently added boolean
  (checkbox/toggle) and enum (dropdown) types.
  (
0585a98f16
,
Manual
### Commit Summary: Generated Rig Features - Blender 4.1 Manual
### Commit Details:
Generated Rig Features
#
After human rig generation a new armature named
rig
will be added to your scene.
This is the character rig you have generated from the human meta-rig and will contain all the features.
Common Features
#
Rig UI Panels
#
The generated rig is accompanied by a script that implements a set of panels that appear in the Item
tab of the 3D view sidebar when a bone belonging to the generated rig is active.
Rig Bake Settings
#
This panel is displayed if the armature has an active
Action
, and
is used by operators that apply an operation to multiple keyframes.
Bake All Keyed Frames
When enabled, the operator computes and keyframes its result on every frame that has a key for any of the
bones, as opposed to just relevant ones.
Limit Frame Range
When enabled, the operator is limited to a certain frame range.
Start, End
Specify the frame range to process.
Get Frame Range
Sets the baking frame range from the scene frame range.
Rig Main Properties
#
This panel shows properties and operators that are relevant to the selected bones.
Rig Layers
#
This panel contains buttons for toggling visibility of bone collections.
The layout and labels of the buttons are defined in the metarig
Bone Collection UI
panel.
Common Controls
#
Rigify rigs are built from standardized components called sub-rigs, which are linked together in a parent-child
hierarchy. Although the precise behavior of each sub-rig is determined by its implementation, there are certain
conventions that are followed by many of them.
Root Bone
#
Every Rigify rig has a bone called
root
, which serves as a parent for all bones of the rig.
It is assigned to a bone collection called
Root
. Unless the metarig has a custom bone
of that name, it is positioned at the origin of the rig object. Its widget looks like
a circle with four arrow shaped protrusions.
Limb Master
#
Many limb-like sub-rigs have a gear-shaped bone at their base.
This bone can in some cases be used to transform the whole sub-rig as a rigid unit, and is also used as a container
for its custom properties that are displayed in the
Rig Main Properties
panel. If you are looking in the Graph
editor for the animated values of the properties, this is most likely the bone to look at.
As an exception, if multiple controls of the sub-rig need their own copy of conceptually the same property,
it may be placed on those controls directly instead.
Tweak Controls
#
These controls look like blue spheres in the default color scheme, and are the final control layer above the
deformation bones themselves.
Tweaks are subordinate to the general IK or FK limb position but can be moved apart, twisted and scaled freely,
even reaching virtually impossible limb shapes.
Rubber Tweak
Some sub-rigs provide a slider in their
Rig Main Properties
when tweaks are selected, which controls
the smoothness of the Bendy Bone joint at that position. When zero, the joint deforms with a sharp bend,
while setting it to 1 makes the transition smooth for a more rubber hose cartoon like appearance.
Custom Pivots
#
Some bones that can be freely moved in space (like IK controls) can be optionally accompanied by a custom pivot
control. These controls usually look like a plain axes empty with the axis lines capped with squares or crosses,
like the one in the image above. The control can be freely moved to change the location of the pivot, and then
rotated or scaled to transform the target bone around the pivot.
IK and FK Switching
#
A number of rig types provides both IK and FK controls (red for IK and green for FK in the image above),
with an ability to switch and snap between them.
Switching is controlled by a slider in
Rig Main Properties
, usually blending between full IK at 0 and full FK at 1.
Snapping one type of controls to the shape of the other is done via buttons, which form a group of three
in their complete set:
The main button will snap on the current frame, and auto-key the result if enabled.
The
Action
button will bake the change on multiple keyframes, according to
Rig Bake Settings
.
The
Clear
button will delete keyframes on the corresponding controls within the bake interval.
Parent Switching
#
Some freely movable controls, e.g. usually the IK controls, can have a mechanism to switch their parent bone
between a set of choices, including the root bone, or none at all.
This mechanism is exposed in the
Rig Main Properties
panel through a row with three controls:
A button that presents a dropdown menu, which allows switching the parent on the current frame while
preserving the bone position and orientation in the world space.
A dropdown input field that directly exposes the switch property for keyframing and direct manipulation.
Changing the value can cause the bone position to jump.
A button to apply the position preserving parent switch over the bake range of keyframes.
Note
When manually placing a Child Of constraint on the control bone, the built-in parent should be switched to none.
Limbs
#
Limbs have a master bone and tweaks. Depending on the user defined meta-rig options,
multiple deform bone segments with tweaks will be created.
The IK control may have an optional custom pivot, as well as additional predefined pivots.
Rigify‚Äôs limbs have the following controls in the Sidebar panel:
FK Limb Follow
Slider
When set to 1 the FK limb will not rotate with the torso and will retain is rotation
relative to the root bone instead.
IK-FK
Slider
Controls whether the limb follows IK or FK controls, blending between full IK at 0 and full FK at 1.
IK<->FK Snapping
Buttons
Snaps one type of controls to another.
IK Stretch
Slider
Blends between the limb stretching freely at 1, or having its maximum length constrained at 0.
Toggle Pole
Switch
When the toggle is Off, the IK limb will use the rotational pole vector (the arrow at the base of the limb).
Rotating/translating/scaling the arrow will control the IK limb base.
When the toggle is On, the classic pole vector will be displayed and used to orient the IK limb.
The arrow will continue to handle the scale and the location of the IK limb base.
Similar to
Parent Switching
, the row includes buttons to convert the current pose between types,
or bake the whole action.
IK Parent
Switch
Switches the effective parent of the main IK control.
Pole Parent
Switch
Switches the effective parent of the classic IK Pole control.
Arms
#
Arms
have the simplest control structure: the IK controls consist of the main IK
control, the optional custom pivot control, and the optional wrist control (the bent circle), which pivots around
the tail rather than the head of the hand bone.
There are no additional controls in the
Rig Main Properties
panel.
Legs
#
Legs
have a more complicated setup, which has:
IK & FK Toe
Optional
Two separate IK and FK controls for the toe (this is  on by default in the bundled metarigs,
and is recommended for stable IK<->FK snapping).
IK Heel
A heel control which can be rotated to command forward or backward roll, sideways rock, or yaw of the heel.
Toe Pivot
Optional
An extra pivot control rotating around the base of the toe.
Custom Pivot
Optional
A custom pivot control.
The properties panel has two additional features:
IK->FK Snap With Roll
Buttons
Standard IK to FK snapping resets the transformations of all IK controls other than the main one. This is
not convenient to use in an animation that involves the use of the heel control, because roll and rock would
be folded into the transformation of the main control.
This alternative snapping operator tries to deduce the rotation of the heel control so as to keep the main
IK control parallel to the ground plane inferred from the
current
orientation of the IK control. The operator
has options to specify which rotational axes to use for the heel control rotation.
Roll On Toe
Slider
Optional
If enabled in the sub-rig settings, this slider can be used to control whether the heel rotation (excluding
backward roll) is applied at the base or the tip of the toe.
Fingers & Tentacles
#
Simple Tentacle
#
The simplest type of rig for a finger or appendage in general is the
simple tentacle
sub-rig. It has only basic FK controls and tweaks,
with the only automation being the ability to copy certain axes of the local rotation of a FK control to the next one.
Advanced Finger
#
For fingers specifically, Rigify has a dedicated
finger
sub-rig type,
which provides:
Master
A master control (orange), which can be used to rotate the finger as a whole, as well as to bend it via Y scaling.
FK Chain
FK control chain (green) that can also operate as semi-tweaks through allowing translation.
IK Control
Optional
IK control for the tip (red).
Note
IK in this sub-rig is rudimentary and operates as an adjustment for FK. The intended way of use is to pose
the finger in FK, and then enable IK after using IK->FK snap if it is necessary to pin the tip of the finger
in place.
The properties panel has the following features:
Finger IK
Slider
Optional
Slider controlling the influence of the IK.
FK<->IK Snapping
Buttons
Optional
Snaps the IK control to the end of the finger, or adjusts the FK controls to the result of the IK correction.
Curvature
Slider
Has the same effect as
Rubber Tweak
on limbs, controlling the rubber hose cartoon effect.
Spline Tentacle
#
Spline Tentacle (Stretch To Fit, Manual Squash & Stretch)
#
Spline Tentacle (Direct Tip Control)
#
The
spline tentacle
is an advanced rig for a flexible appendage (tentacle)
based on the
Spline IK
constraint. The IK control bones manage
control points of a Bezier spline curve, which in turn is followed by the IK chain.
The tentacle can be generated in three major modes:
Stretch To Fit
In this simplest mode all bones of the sub-rig deform chain follow the curve and squash & stretch to match
its length.
Manual Squash & Stretch
This mode is almost the same, but the chain does not automatically scale to match the curve length.
Instead, it tries to cover as much as possible of the curve given its manually scaled length.
If the curve is too short, the chain will overhang it and straighten out, but this can result in jitter.
Direct Tip Control
This mode is more similar to the behavior of IK limbs: the final bone of the chain is directly controlled by
the tip IK control, while the other bones of the chain stretch and follow the curve to bridge the gap.
The tentacle sub-rig has the following control bones:
Master
The tentacle has the same gear master control as other limbs (seen as a line in the images).
IK Start
The IK control at the base of the tentacle, which can be used to control the base twist and sideways scale, and
is one of the potential switchable parents for other IK controls.
In the
Manual Squash & Stretch
mode it controls uniform scale of the tentacle in all directions.
IK Start (Extra)
Optional
Extra start controls, optional and hidden by default. Switchable parents default to the
IK Start
control.
The scale of the control may optionally affect the thickness of the chain via the radius of the curve point.
IK Middle
Controls for the middle of the curve. The switchable parents default to
Master
, but may be set to
IK Start
or
IK End
controls.
The scale of the control may optionally affect the thickness of the chain via the radius of the curve point.
IK End (Extra)
Optional
Extra end controls, optional and hidden by default. Switchable parents default to the
IK End
control.
The scale of the control may optionally affect the thickness of the chain via the radius of the curve point.
The
Direct Tip Control
mode adds one more extra end control next to the middle ones that cannot be hidden.
IK End
Controls the last control point of the curve, and is one of the potential parents for the other chain controls.
In the
Direct Tip Control
mode also directly controls the last bone of the chain.
IK End Twist
Optional
This control is visually attached to the last bone of the chain, and must use Euler rotation.
Stretch To Fit
: it controls the twist of the tip of the tentacle, interpolated to nothing at the base.
Manual Squash & Stretch
: it also controls the scaling of the tip of the tentacle.
Direct Tip Control
: the control does not exist.
FK Chain
Optional
If enabled, the rig has an alternative fully FK control chain.
The properties panel has the following features:
Start/End Controls
Optional
If extra controls exist, this property controls how many of them are visible and active.
When a control is disabled, it is snapped to a position extremely close to the corresponding end control point,
thus effectively neutralizing its effect. Thus, changing the setting during an animation can cause jumps.
The plus and minus buttons can help with maintaining a continuous transition in an animation by keyframing the
change in the property value with Constant interpolation, and also snapping and keyframing the control itself
to its ‚Äòhidden‚Äô position.
End Twist Estimate
Optional
In the
Direct Tip Control
mode the twist at the end of the tentacle is deduced from the free form orientation
of the tip control, rather than using a separate twist control with constrained Euler rotation. However, for
technical reasons, that can only give values within the 180 degrees range of neutral.
A long tentacle can accept more twist than 180 degrees, so a workaround is necessary. This property allows
specifying an approximate estimate of the twist value (effectively shifting the neutral position), and the
rig then applies the automatic correction within 180 degrees of this value.
IK-FK, IK<->FK Snapping
Optional
If the FK controls are enabled, these provide standard IK-FK switching and snapping.
However, unlike other limbs, for this rig automatic IK to FK snapping can only be approximate and requires
manual tuning. For this reason, buttons for baking the snapping over a range of keyframes are not provided.
Parent Switch
Switches the parent of the selected IK control.
Spine, Head & Tail
#
Spine
#
The
spine
sub-rig provides a cube shaped torso control with
switchable parent, and bent circle shaped hip and chest controls subordinate to it. For low level deformation
tweak controls are provided.
The torso control can optionally be accompanied with a custom pivot control. The rig can also optionally
provide a full set of FK controls that are subordinate to the normal simplified ones, but above tweaks.
The rig properties panel for the spine controls usually includes options for the head and/or tail as well.
Head
#
The
head
sub-rig attaches to the end of the spine, and provides
rotational controls for the head and neck, as well as tweaks for fine control of the neck.
If the neck is three or more bones long, an additonal tweak-like translational
neck bend control is provided (the widget looks like a circle with arrows).
The properties panel contains the following options:
Neck Follow
Slider
This slider controls the rotations isolation for the neck bones.
The neck will follow the orientation of the Torso when set to 0, and the Chest when set to 1.
Head Follow
Slider
This slider controls the rotations isolation for the head.
The head will follow the orientation of the Torso when set to 0, and the Chest when set to 1.
Tail
#
The
tail
sub-rig attaches to the start of the spine, and provides
FK controls for the tail, as well as a master control that replicates its local rotation around certain axes
to all individual bones.
The properties panel contains the following options:
Tail Follow
Slider
This slider controls the rotations isolation for the tail.
The tail will follow the orientation of the Torso when set to 0, and the Hips when set to 1.
Face
#
Note
This describes the new-style modular face produced by the Upgrade Face operator button.
Basic Concepts
#
Skin Bone Chains
#
The foundation of the Rigify face is a network of Bendy Bone
chains
with
controls placed at every bone end. These controls affect all bones that meet at that specific point.
When the controls are merely translated, the B-Bone chains retain the normal automatic bezier handle behavior.
Local rotation and/or scaling of the controls are applied on top of that.
In case of
certain chains
, the transformation of the end and/or middle
controls is interpolated to other controls located between them. In such cases the controls often have different
colors and/or shapes.
Additionally, certain controls have
arbitrary constraints
that partially copy
transformation from nearby control points.
Specialized Controllers
#
Certain areas of the face, like eyes or mouth, have additional specialized controllers that apply custom behavior
on top of the chains and their controllers within the relevant area.
Eyes
#
The
eyes
have the following controls in addition to the eyelid chains:
Master
This large circular control can be used to transform the whole eye as one unit.
Common Target
This large control enveloping all individual eye targets has a switchable parent and can
be used to specify the point that the eyes should look at.
Eye Target
These small circle controls within the common target control specify the point targeted by each
individual eye. Their local scale can also be used to affect the iris or pupil of the eye,
depending on how it was weight painted.
The rig properties panel contains the following options:
Eyelids Follow
Slider
Controls how much the rotation of the eyeball affects the eyelids. Depending on the sub-rig generation
options, this slider can be split to separately control the horizontal and vertical directions.
Eyelids Attached
Slider
Optional
If enabled in the sub-rig generation options, this slider can be used to disable the mechanism that
forces the eyelids to conform to the sphere of the eye.
Parent
Parent Switch
Selects the parent for the common target control.
Mouth
#
The
mouth
has the following controls:
Jaw Master
Controls rotation of the jaw, directly affecting the main jaw deform bone, as well
as chains fully belonging to the jaw. Chains forming the lip loop(s) are adjusted to
open the mouth as the jaw rotates or moves.
Mouth Master
This control uniformly transforms the lips without moving the jaw.
The rig properties panel contains the following options:
Mouth Lock
Slider
This slider can be changed from 0 to 1 in order to suppress opening of the mouth
when the jaw rotates or moves.
-------
)
glTF 2.0
¬∂
Importer
¬∂
New features & enhancements
¬∂
Implement KHR_materials_anisotropy import
  (
d6b9e57135
)
Refactor material import
  (
f407b20752
,
c689c7b5c6
,
3b0b64b01e
,
5bf2cbd6b9
)
Convert pbrSpecularGlossiness for Principled v2
  (
0d3045d8f6
)
Perf: Use NumPy for TRIANGLE STRIP and TRIANGLE FAN mode primitives
  (
8e33a044e7
)
Updates for Blender Python API changes from Blender 3.2 to 4.1
  (
ba5edfcb15
)
Fixes
¬∂
Use channel_packed at import
  (
74834adca0
)
Avoid crash when custom property type is not managed
  (
0c77594325
)
Change naming format of imported Color Attribute, to follow Blender naming
  (
650caaa5fb
)
Fix importing certain textures with no source
  (
8b0c3b5bad
)
Change scaling factor of default custom bones
  (
c10a443bed
)
Remove no more needed check
  (
01e53a53c4
)
Exporter
¬∂
New features & enhancements
¬∂
Experimental GN instances export
  (
c24d76a44e
)
Implement KHR_materials_anisotropy export
  (
d6b9e57135
)
Add option to filter actions
  (
794446d1ca
)
Manage udim at export (conversion)
  (
666b21d1b0
)
Add option to use shared accessors
  (
625590cb21
)
Option to export full collection hierarchy
  (
3f7c77cf18
)
Option to export unused images & textures
  (
991a42b30d
,
a5d223459e
)
Add postprocessing using gltfpack
  (
97d4736cf0
)
Manage shader node groups traversal
  (
b80a0232de
)
Remove armature object at export when possible
  (
1ea6ea87bd
)
Add option to flatten scene hierarchy
  (
a388a95ba7
)
Manage texture direcly plugged when possible
  (
7f99be2c7d
)
Export VC only when needed
  (
90a3c15589
)
Add a mesh hook
  (
770600758d
)
Fixes & maintenance
¬∂
Add glTF Embedded format option back - with option
  (
7a5c650a01
)
Update needed after autosmooth removal
  (
b1fbf73a08
)
Fix crash when sk driver on non deformation bone when it's not exported
  (
607e95a087
)
Fix regression in image quality option
  (
75c8369bbd
)
Fix crash when NaN in SK
  (
08a87a6e99
)
Avoid crash when curve has armature modifier
  (
6ad4928ff3
)
Check parent type to determine if a node is really a child of a bone
  (
19768924da
)
Fix exporter Vertex Color when no material
  (
2dfdcb0f7e
)
Fix metallicRougness factors
  (
62b9a6c9da
)
Fix exporting animation when gpu instancing is enabled
  (
e936f80134
)
Take fps_base into account
  (
720c357b7f
)
Check glTF node group with suffixes too
  (
433dfd5368
)
Add a check to avoid crash when there is a mesh without any data in it
  (
55716a27dd
)
Fix Checking material id when apply modifiers
  (
8e204c2e9f
)
Check VC directly on Base Color socket
  (
3272f2702d
)
1 keyframe actions must not have CUBISPLINE interpolation
  (
7d13b7b06d
)
Fix UVMap as Custom Attribute FLOAT2 or FLOAT3
  (
47c669dcf8
)
Perf: Find unique structured array elements more efficiently
  (
a8111fc296
)
Updates for Blender Python API changes from Blender 3.2 to 4.1
  (
ba5edfcb15
)

'''''

